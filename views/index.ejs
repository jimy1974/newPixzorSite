<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Character Encoding -->
    <meta charset="UTF-8">
    
    <!-- Viewport for Responsive Design -->    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">


    <!-- Page Title -->
    <title><%= title %></title>

    <!-- Meta Description and Keywords -->
    <meta name="description" content="Create stunning AI-generated images with Pixzor. Transform your creative vision into reality with advanced tools for character consistency, face swap, and storytelling. Future plans include AI-powered video animation for subscribers.">
    <meta name="keywords" content="AI image generation, AI video creation, character design, face swap, AI storytelling, generative AI, creative tools, character consistency, AI animation">
    <meta name="author" content="Pixzor">

    <!-- Open Graph Meta Tags (for social sharing) -->
    <% if (imageUrl) { %>
        <meta property="og:title" content="<%= title %>" />
        <meta property="og:description" content="<%= description %>" />
        <meta property="og:image" content="<%= imageUrl %>" />
        <meta property="og:url" content="<%= url %>" />
        <meta property="og:type" content="website" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="628" />
    <% } %>

    <!-- Twitter Meta Tags (for social sharing) -->
    <% if (imageUrl) { %>
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="<%= title %>" />
        <meta name="twitter:description" content="<%= description %>" />
        <meta name="twitter:image" content="<%= imageUrl %>" />
    <% } %>

    <!-- Structured Data (JSON-LD) for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "url": "https://www.pixzor.com/",
        "name": "Pixzor",
        "description": "AI-powered platform for creating stunning images and videos. Transform your creative vision into reality with advanced tools for character consistency, face swap, and storytelling.",
        "contactPoint": {
            "@type": "ContactPoint",
            "email": "contact@pixzor.com",
            "contactType": "customer support"
        },
        "potentialAction": {
            "@type": "SearchAction",
            "target": "https://www.pixzor.com/search?q={search_term_string}",
            "query-input": "required name=search_term_string"
        }
    }
    </script>

    <!-- Tailwind CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.16/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <script src="https://js.stripe.com/v3/"></script>

 
    
  <style>
    
    .fixed-prompt {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%; /* Ensure it takes most of the screen's width */
      max-width: 1200px; /* Cap it for larger screens */
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);      
      border-radius: 12px 12px 0 0;
      padding: 16px; /* Reduce padding slightly */
    }
      
    /* General Button Styles */
    .custom-button {
      background-color: #374151; /* Tailwind's bg-gray-800 */
      color: white; /* Text color */
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem; /* Rounded corners */
      font-size: 0.875rem; /* Tailwind's text-sm */
      padding: 0 1rem; /* Horizontal padding */
      transition: background-color 0.2s, box-shadow 0.2s; /* Smooth transitions */
      cursor: pointer; /* Pointer cursor on hover */
    }

    /* Hover Effect */
    .custom-button:hover {
      background-color: #4b5563; /* Tailwind's bg-gray-700 */
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow effect */
    }

    /* Selected Toggle Button */
    .custom-button.selected-toggle {
      background-color: #d1d5db; /* Tailwind's bg-gray-300 (light gray) */
      color: #1f2937; /* Dark gray text color for contrast */
      font-weight: bold; /* Emphasize selected button */
      box-shadow: inset 0px 2px 4px rgba(0, 0, 0, 0.2); /* Adds subtle inset shadow */
    }

    /* Rounded Button Styles */
    .custom-button.rounded-l-lg {
      border-top-left-radius: 0.5rem; /* Left rounded corner */
      border-bottom-left-radius: 0.5rem;
    }

    .custom-button.rounded-r-lg {
      border-top-right-radius: 0.5rem; /* Right rounded corner */
      border-bottom-right-radius: 0.5rem;
    }

    /* Hidden Button */
    .custom-button.hidden {
      display: none; /* Hide the button */
    }


    /* Add padding to the main content to prevent overlap with the fixed prompt box */
    .content-padding {
      padding-bottom: 300px; /* Adjust based on the prompt box height */
      padding-top: 60px; /* Adjust based on the height of your navbar */
    }

      
    #public-toggle {
      border-radius: 8px 0 0 8px; /* Rounded left corners */
    }

    #profile-toggle {
      border-radius: 0 8px 8px 0; /* Rounded right corners */
    }

    #friend-toggle {
      border-radius: 0; /* No rounded corners for the middle button */
    }


    /* Modal backdrop */
    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black */
    }

    /* Logo Placeholder */
    .logo {
      width: 40px;
      height: 40px;
      background-color: #4b5563; /* Gray background */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 1.2rem;
    }

    /* Fixed Generated Images Container */
    .generated-images-container {
      max-height: 80vh;
      overflow-y: auto;
    }

    /* Selected Toggle Button Style */
    .selected-toggle {
      background-color: #a1a1aa; /* Light Gray */
      color: white;
    }

 

    

    nav {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1); /* Light border */
      border-top: 4px solid #ffffff; /* White top for visibility */
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Badges */
    .badge-public {
      display: inline-block;
      background-color: green;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .badge-private {
      display: inline-block;
      background-color: red;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    /* Error Message Styling */
    #error-message {
      display: block;
      margin-top: 10px;
      font-size: 0.875rem;
      color: #f87171; /* Tailwind's red-400 */
    }

    /* Toast Notification Container */
    #toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
    }

    /* Toast Styles */
    .toast {
      background-color: #1f2937; /* Dark background */
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 10px;
      opacity: 0.95;
      transition: opacity 0.3s ease;
    }

    .toast-success {
      background-color: #10b981; /* Green */
    }

    .toast-error {
      background-color: #ef4444; /* Red */
    }

    .hidden {
      display: none;
    }
      
   
    #post-visibility-toggle:checked + .block {
      background-color: #10b981; 
    }
    #post-visibility-toggle:checked + .block + .dot {
      transform: translateX(4px); 
    }
      
   #post-visibility-button:hover + #post-visibility-tooltip {
      display: block;
    }
      
    .post-visibility-wrapper {
      position: relative; 
    }


   
    .toggle-visibility-button {
      margin-left: 4px; /* Add some space between buttons */
      display: inline-block; /* Align with other buttons */
   }
    .bg-gray-100 {
      background-color: #f9f9f9; /* Light gray background */
    }
    .text-gray-900 {
      color: #111827; /* Dark text for contrast */
    }

   #close-comments-modal {
      font-size: 24px;
      font-weight: bold;
      line-height: 1;
      cursor: pointer;
      z-index: 10; /* Ensure it is above other elements */
      color: #555; /* Default color */
    }
/* Modal content */
#comments-modal > div {
  background-color: white;
  border-radius: 8px;
  
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
      
  #comments-modal {
    z-index: 1050; /* A value higher than the prompt box */
  }
      
 #comments-modal > div {
  width: 90%; /* Default width */
  height: 90%; /* Default height */
  display: flex;
  flex-direction: row;
  overflow: hidden;
}
#comments-modal .bg-white {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
      
.full-size-image {
  transition: transform 0.2s ease;
  cursor: zoom-in;      
}
      
/* Magnifying glass visibility */
#modal-image:hover + span {
  opacity: 1; /* Makes magnifying glass visible on hover */
}

/* Default state for the magnifying glass */
#modal-image + span {
  opacity: 0;
}

/* Text adjustments */
.text-black {
  color: black;
}

textarea#comment-input {
  color: black; /* Ensures visible text in comments input */
}
/* Magnifying glass visibility */
.group:hover .group-hover\:opacity-100 {
  opacity: 1;
}
.group-hover\:opacity-100 {
  opacity: 0;
}

/* Text shadow for magnifying glass */
.drop-shadow-md {
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7), -2px -2px 4px rgba(255, 255, 255, 0.7);
}

#modal-image {
  position: relative;
  padding: 10px;
  background: white; 
  border-radius: 8px;
}

#modal-prompt-container {
  height: 6rem; 
}
#comments-list {
  background-color: #ffffff; /* Optional: Set a light background */
  padding: 10px;
  border-radius: 5px;
}

#comments-list li {
  color: black; /* Ensures text is visible */
  font-size: 1rem;
  line-height: 1.5; /* Optional: Improves readability */
  margin-bottom: 8px; /* Adds spacing between comments */
}
#comments-list li {
  display: flex;
  align-items: flex-start;
  margin-bottom: 10px;
}

#comments-list img {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
}

#comments-list p {
  margin: 0;
}

#comments-list .font-bold {
  margin-bottom: 2px;
}


#copy-prompt {
  cursor: pointer; /* Make it clear the button is clickable */
  font-size: 1rem; /* Adjust size to match the title */
  margin-left: 8px; /* Add space between the title and the icon */
  background: none; /* Remove any default button styling */
  border: none; /* Remove border */
  padding: 0; /* Remove extra padding */
}
#copy-prompt:hover {
  color: #1f2937; /* Slight color change on hover */
}

#comments-modal {
  overflow-y: auto;  /* Allow vertical scrolling for the entire modal */
  -webkit-overflow-scrolling: touch;  /* Smooth scrolling on iOS */
}

#comments-modal > div {
  max-height: 90vh;  /* Limit height to 90% of viewport height */
  overflow-y: auto;  /* Enable scrolling for the modal content */
}

/* Ensure the comments list can scroll independently */
#comments-list {
  max-height: 50vh;  /* Limit comments list height */
  
}
      




@media (max-width: 768px) { 
  /* Ensure the modal container doesn't scroll the background */
    body.modal-open {
      overflow: hidden;
    }

    /* Make the modal content scrollable */
    #comments-modal {
      overflow: auto;
      max-height: 100vh; /* Limit modal height to the viewport */
    }

    #comments-modal .flex-grow.overflow-hidden {
      overflow-y: auto; /* Enable vertical scrolling for the comments section */
      max-height: 60vh; /* Adjust based on desired modal height */
    }
    
    
  #comments-modal > div {
    flex-direction: column; 
    height: auto;
  }
  #comments-modal .bg-gray-100 {
    width: 100%; 
  }
  #comments-modal .p-6 {
    width: 100%; 
  }
}

      

#prompt-input {
  width: 100%;
  background-color: #374151;
  color: white;
  border: 1px solid #4b5563;
  border-radius: 0.5rem;
  padding: 0.5rem 4rem 0.5rem 0.5rem;
  font-size: 0.875rem;
  resize: none;
  overflow-y: hidden;
  min-height: 2.5rem;
  max-height: 10rem;
  line-height: 1.25;
  
  /* Add these properties */
  word-wrap: break-word;
  word-break: break-word;
  white-space: pre-wrap;
  box-sizing: border-box;
  display: block;

}

.absolute.right-2.top-2 {
  right: 0.5rem;
  top: 0.5rem;
}

@media (max-width: 640px) {
  #prompt-input {
    max-height: 8rem;
    padding-right: 3.5rem;
  }

  .absolute.right-2.top-2 {
    right: 0.25rem;
    top: 0.25rem;
  }
}
      
      
      
.bottom-action-bar {
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: #2d3748; /* Tailwind's bg-gray-800 equivalent */
  display: flex;
  justify-content: center; /* Align buttons to the center */
  padding: 16px;
  box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.2); /* Add subtle shadow for elevation */
  border-radius: 12px 12px 0 0; /* Match rounded style */
}

/* General styles for buttons */
.large-button {
  background-color: #4b5563; /* Tailwind's bg-gray-600 equivalent */
  color: white;
  font-size: 1rem;
  padding: 8px 16px; /* Slightly smaller padding */
  margin: 0 4px; /* Reduce margin */
  border: none;
  border-radius: 8px; /* Rounded corners */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem; /* Space between icon and text */
  transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth hover effects */
  cursor: pointer;
}

.large-button i {
  font-size: 1.2rem; /* Icon size */
}

/* Hover effects */
.large-button:hover {
  background-color: #10b981; /* Tailwind's green-500 equivalent for hover */
  transform: scale(1.05); /* Slightly larger on hover */
}



.hidden {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.visible {
  opacity: 1;
  visibility: visible;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

      
.upload-container, .search-container {
  padding: 20px;
  background-color: #2d3748; /* Tailwind's bg-gray-800 */
  border-radius: 12px;
  box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.3);
  margin: 20px auto;
  max-width: 80%;
}

h2 {
  font-size: 1.25rem;
  margin-bottom: 1rem;
}

#search-results img {
  max-width: 100%;
  border-radius: 8px;
  margin-bottom: 10px;
}
      
      
.modal {
  display: none; /* Hidden by default */
}

.modal-content {
  animation: fadeIn 0.3s ease-in-out; /* Smooth fade-in animation */
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.hidden {
  display: none !important;
}
.modal-content {
  outline: 2px solid red; /* Temporary outline for debugging */
}

.upload-container {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 50;
  background-color: #2d3748;
  padding: 20px;
  box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.3);
}
.search-container {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 50;
  background-color: #2d3748;
  padding: 20px;
  box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.3);
  overflow-y: auto; /* Allow vertical scrolling if content exceeds height */
  display: flex;
  flex-direction: column; /* Stack children vertically */
  gap: 10px; /* Add space between elements */
}

.search-container h2 {
  margin-bottom: 8px; /* Reduce the bottom margin */
}

.search-container .flex {
  margin-top: 0; /* Remove extra margin at the top of the input container */
}


  
/* Close Button */
#close-sidebar {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: white;
}

#close-sidebar:hover {
  color: #ccc;
}



/* Default filter button style */
.filter-button {  
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 0.875rem;  
  transition: background-color 0.2s ease, transform 0.2s ease;
  position: relative; /* Ensure pseudo-elements are positioned relative to this button */
  padding-right: 35px; /* Add space for the tick to the right */
  transition: background-color 0.2s ease, color 0.2s ease; /* Smooth transition */    
}

/* When selected, show light gray and a red or yellow tick */
.filter-button.selected {
  background-color: #4b5563; /* Slightly lighter gray */
  color: white;
}

.filter-button:hover {
  background-color: #374151; /* Tailwind's bg-gray-700 for hover */
  
}

.filter-button.selected::after {
  content: "✔"; /* Red or Yellow tick */
  
  position: absolute;
  right: 8px; /* Position tick to the far right */
  top: 50%; /* Center tick vertically */
  transform: translateY(-50%); /* Align the tick properly */
  font-size: 1rem;
}


      
#open-filters-button:hover {
  background-color: #10b981; /* Green hover */
  transform: scale(1.05); /* Slight zoom effect */
}


[data-category="image-source"] .selected::before {
  color: #ff6347; /* Example: Orange arrow for "Image Source" */
}

[data-category="art-styles"] .selected::before {
  color: #1e90ff; /* Example: Blue arrow for "Art Styles" */
}

[data-category="advanced"] .selected::before {
  color: #32cd32; /* Example: Green arrow for "Advanced Filters" */
}

     
select {
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='white'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.5rem center;
  background-size: 1.2em;
  padding-right: 2rem;
}
      
.custom-select {
  background-color: #374151;
  color: white;
  height: 32px;
  padding: 0 2rem 0 0.5rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='white'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.5rem center;
  background-size: 1.2em;
  appearance: none;
  max-width: 150px; /* Limit the maximum width */
  width: 100%; /* Ensure it takes up available space */
}




.fixed-prompt .container {
  padding-top: 0; /* Remove padding only from the top */
}



.fixed-prompt .flex-col {
  gap: 0; /* Remove extra vertical spacing between elements */
}

button.down-arrow-btn {
  background-color: #374151; /* Tailwind's bg-gray-700 */
  color: white;
  height: 24px; /* Adjust height to match design */
  width: auto; /* Ensure it’s not overly wide */
  padding: 0 8px; /* Minimal padding for arrow */
  margin: 0; /* Remove all margins */
  border-radius: 8px; /* Keep a small rounded corner */
  display: flex;
  align-items: center;
  justify-content: center;
}

button.down-arrow-btn:hover {
  background-color: #4b5563; /* Slightly lighter gray on hover */
}

.flex.justify-center {
  margin: 0; /* Remove extra margin around the button container */
  padding: 0; /* Remove extra padding */
}

      
.toggle-buttons.hidden {
  display: none;
}
.toggle-buttons {  
  display: flex;
  justify-content: space-around; /* Spread buttons evenly */
  gap: 0.5rem; /* Add spacing between buttons */
    
}
      
/* Default button styles */
.toggle-buttons button {
  background-color: #374151; /* Default dark gray */
  color: white; /* Text color */
  font-size: 0.875rem; /* Base font size */
  padding: 0.5rem; /* Padding for buttons */
  border: none; /* Remove default borders */
  border-radius: 0.375rem; /* Rounded corners */
  cursor: pointer; /* Pointer cursor */
  transition: background-color 0.2s ease, color 0.2s ease; /* Smooth transition */
}

/* Hover effect (dark green highlight) */
.toggle-buttons button:hover {
  background-color: #14532d; /* Dark green for hover */
  color: #e5f4e3; /* Light greenish text for hover */
}

/* Active state (green background when clicked) */
button.active {
  background-color: #4caf50; /* Bright green background */
  color: white; /* Keep text white */
  box-shadow: inset 0px 2px 4px rgba(0, 0, 0, 0.2); /* Subtle inset shadow */
}

      
    
/* Action buttons responsive layout */
.action-buttons {
  
  flex-direction: row; /* Ensure buttons stay side by side */
  justify-content: flex-start;
  gap: 0.5rem; /* Ensure consistent spacing between buttons */
}




   
      




@media (max-width: 640px) {
    
  .large-button {
    font-size: 0.8rem; /* Smaller text */
    padding: 6px 12px; /* Less padding */
    margin: 0 2px; /* Reduce spacing further */
    gap: 0.3rem; /* Smaller gap between icon and text */
  }
    
   /* Custom styles for the fixed prompt box */
  .fixed-prompt {
      position: fixed;
      bottom: 0;
      
      width: 100%;
      
      overflow-y: auto;
      z-index: 50;
      padding-top: 4px;
      padding: 5px;    
    }  
  .fixed-prompt .flex-col {
    gap: 0.5rem;
  }
      
  .content-padding {
    padding-bottom: 200px;
    padding-top: 50px;
  }
  
 
  
  #prompt-input {
    font-size: 0.875rem;
    padding: 8px 160px 8px 8px;
    width: 100%;
    border: 1px solid #ccc;
    border-radius: 6px;
  }
  

  
  select {
    height: 32px;
  }
  .toggle-buttons {
    flex-direction: row; /* Ensure buttons stay side by side */
    align-items: center; /* Center buttons vertically */
    justify-content: space-around; /* Spread buttons evenly */
    gap: 0.25rem; /* Adjust spacing for smaller screens */
  }

  .toggle-buttons button {
    font-size: 0.75rem; /* Make text smaller */
    padding: 0.5rem; /* Reduced padding for smaller buttons */
  }

  .action-buttons {
    flex-direction: row; /* Ensure action buttons stay side by side */
    align-items: center; /* Vertically center align */
    justify-content: flex-start;
    gap: 0.25rem; /* Reduce gap for smaller screens */
  }

  .action-buttons button,
  .action-buttons a {
    font-size: 0.75rem; /* Smaller font size for compact layout */
    padding: 0.5rem; /* Reduced padding for smaller buttons */
  }
}
#options-button {
  pointer-events: auto !important; /* Ensure it's always clickable */
}



/* Ensure the fullscreen modal fills the viewport */
#fullscreen-modal {
  z-index: 1100; /* Higher than #comments-modal */
}
  
#fullscreen-modal {
  position: fixed;
  inset: 0;
  z-index: 1100; /* Higher than #comments-modal */
  background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent black background */
  display: flex;
  justify-content: center;
  align-items: center;
}

#fullscreen-image {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  touch-action: pan-x pan-y; /* Enable pinch-to-zoom */
  user-select: none; /* Prevent text selection */
  transform-origin: center center; /* Zoom from the center */
  transition: transform 0.2s ease; /* Smooth zoom transition */
}

#close-fullscreen-modal {
  position: absolute;
  top: 20px;
  right: 20px;
  background-color: red;
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 24px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
}
      
 
/* Buy Tokens Modal */
#buy-tokens-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5); /* Semi-transparent backdrop */
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  overflow-y: auto; /* Allow scrolling if content exceeds height */
}


/* Ensure the dropdown menu is fully visible */
/* Adjust the dropdown height and text alignment */
#token-bundle {
  height: 48px; /* Increase the height */
  padding: 12px 8px; /* Add more padding for better spacing */
  line-height: 1.5; /* Ensure text is vertically centered */
  font-size: 16px; /* Adjust font size if needed */
  border: 1px solid #ccc; /* Ensure the border is visible */
  border-radius: 8px; /* Match your design */
  appearance: none; /* Remove default arrow */
  
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 16px;
}

/* Adjust modal content for smaller screens */
@media (max-width: 640px) {
  #buy-tokens-modal > div {
    width: 95%; /* Use more screen width on small devices */
    padding: 16px; /* Reduce padding for better fit */
  }

  #token-bundle {
    font-size: 14px; /* Smaller font size for dropdown */
  }
}
      
/* Ensure the dropdown menu appears above the modal */
.dropdown-menu {
  z-index: 1001; /* Higher than the modal's z-index */
  position: relative; /* Ensure it respects the z-index */
}

/* Adjust the modal's overflow property */
#buy-tokens-modal {
  overflow: visible; /* Allow dropdown to overflow */
}

#buy-tokens-modal > div {
  overflow: visible; /* Ensure the modal content doesn't clip the dropdown */
}      
      
      
      
/* Update the sidebar styles */
#filter-sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 250px;
  height: 100%;
  z-index: 5000;
  background-color: #1a202c;
  border-right: 1px solid #2d3748;
  color: white;
  box-shadow: 2px 0 6px rgba(0, 0, 0, 0.5);
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #4b5563 #1a202c;
  transform: translateX(-100%);
  transition: transform 0.3s ease-in-out;
  padding: 16px;
}
      
/* Backdrop styling */
#sidebar-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 4999;
  display: none; /* Hide by default */
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

/* Show backdrop when sidebar is open */
#filter-sidebar.open ~ #sidebar-backdrop {
  display: block;
  opacity: 1;
}

/* Ensure the sidebar is above the backdrop */
#filter-sidebar.open {
  transform: translateX(0);
  animation: bounce-in 0.5s ease-in-out;
}

/* Keep existing animations and other styles */
@keyframes bounce-in {
  0% { transform: translateX(-100%); }
  40% { transform: translateX(10px); }
  100% { transform: translateX(0); }
}
      
#welcome-modal {
  pointer-events: none; /* Allow clicks to pass through */
}

#welcome-modal > div {
  pointer-events: auto; /* Allow clicks within the modal */
}      
      

/* Adjust modal width for small screens */
@media (max-width: 400px) {
  #options-modal .max-w-md {
    max-width: 90%; /* Reduce modal width on small screens */
    padding: 1rem; /* Reduce padding for better spacing */
  }

  #options-modal input,
  #options-modal select,
  #options-modal input[type="range"] {
    font-size: 14px; /* Reduce font size for better fit */
  }

  #options-modal .custom-button {
    padding: 0.5rem 1rem; /* Adjust button padding */
  }

  #options-modal #image-strength-modal {
    width: 100%; /* Ensure the slider takes full width */
  }
}
      
      

      
/* Default thumbnail size */
.thumbnail-image {
  width: 5rem; /* w-20 in Tailwind (20 * 0.25rem = 5rem) */
  height: 5rem; /* h-20 in Tailwind */
  border: 1px solid #ccc; /* Optional: Add a border for better visibility */
}

/* Reduce thumbnail size on mobile screens */
@media (max-width: 640px) {
  .thumbnail-image {
    width: 2.5rem; /* Half the size (2.5rem) */
    height: 2.5rem; /* Half the size (2.5rem) */
    margin-left: 0.1rem; /* Reduce left margin for better spacing */
  }
}
@media (max-width: 640px) {
  #prompt-input {
    font-size: 16px; /* Increase font size for better readability on mobile */
    padding: 8px; /* Adjust padding for mobile */
    min-height: 3rem; /* Increase minimum height for mobile */
  }
}



      
      
.custom-dropdown {
  position: relative;
  width: 200px;
  border: 1px solid #4a5568;
  border-radius: 4px;
  background-color: #2d3748;
  color: white;
  cursor: pointer;
  height: 32px;  
  max-width: 100px;    
}

.selected-option {
  display: flex;
  align-items: center;
  padding: 8px;
  justify-content: space-between;
}

.selected-option i {
  margin-right: 8px;
  color: #cbd5e0;
}

.dropdown-options {
  display: none; /* Hide by default */
  position: absolute;
  bottom: calc(100% + 8px); /* Add some space between the dropdown and options */
  left: 0;
  width: 100%;
  background-color: #2d3748;
  border: 1px solid #4a5568;
  border-radius: 4px 4px 0 0;
  z-index: 6000; /* Ensure it's above other elements */
  max-height: 200px; /* Limit height to prevent overflow */
  overflow-y: auto; /* Add scroll if options exceed max height */
    
  padding: 0 2rem 0 0.5rem;        
}

.custom-dropdown.open .dropdown-options {
  display: block; /* Show when open */
}

/* Ensure the parent container doesn't clip the dropdown */
.fixed-prompt {
  overflow: visible; /* Allow dropdown to overflow */
}
/* Mobile styles */
@media (max-width: 768px) {
  .custom-dropdown {
    width: auto; /* Adjust width to fit content */
    min-width: 50px; /* Minimum width to prevent it from being too small */
  }

  .selected-option span {
    display: none; /* Hide "Ratio" text on mobile */
  }

  .selected-option i {
    margin-right: 0; /* Remove margin between icons */
  }

  .dropdown-options {
    width: auto; /* Adjust width to fit content */
    min-width: 120px; /* Minimum width for options */
  }
}
      
      
#generate-button {
  height: 32px;  
  max-width: 80px;        
  padding: 0.5rem 1rem; /* Adjust padding for better spacing */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem; /* Add spacing between text and icon (if needed) */
}

/* Hide the icon by default */
.generate-icon {
  display: none;
}

/* Ensure the Visibility Button and Generate Button are aligned */
#post-visibility-button {
  margin-right: 0.5rem; /* Add spacing between Visibility Button and Generate Button */
}

/* On mobile screens, adjust spacing */
@media (max-width: 640px) {
  #post-visibility-button {
    margin-right: 0.25rem; /* Smaller spacing for mobile */
  }

  #generate-button {
    min-width: auto; /* Allow the button to shrink */
    padding: 0.5rem; /* Smaller padding for mobile */
  }
}
      
      
      
      
      
.like-button:hover {
    background-color: rgba(255, 255, 255, 0.1); /* Slight hover effect */
    transform: scale(1.1); /* Slight zoom on hover */
}




.like-button i.liked {
    color: red; /* Liked heart color */
}

.liked {
    color: red; /* Red when liked */
}


.image-card .toggle-buttons {
    /*position: absolute;*/
    bottom: 8px; /* Adjust for spacing */
    left: 8px;
    right: 8px;
    /*display: flex;*/
    justify-content: space-around;
}

.image-card {
  position: relative;
  overflow: hidden; /* Ensures image scaling doesn't affect layout */
  border-radius: 12px; /* Matches other rounded elements */
}

.image-card:hover img {
  transform: scale(1.05); /* Slight zoom on hover */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); /* Add shadow */
}

      
.like-button {
  position: absolute;
  top: 8px; /* Adjust positioning */
  right: 8px; /* Adjust positioning */
  width: 40px; /* Set button width */
  height: 40px; /* Set button height */
  background-color: transparent; /* Transparent background */
  border: 2px solid rgba(255, 255, 255, 0.3); /* Optional border for visibility */
  border-radius: 50%; /* Make the button circular */
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2); /* Subtle shadow */
  transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out;
}
.like-button i {
  color: white; /* Set the heart color */
  font-size: 1.2rem; /* Adjust size */
  transition: color 0.2s ease-in-out;
}      
.like-button.liked i {
  color: #f00; /* Highlighted heart color for liked state */
} 
      
      
/* Masonry Layout with CSS Columns */
/* Masonry Container */
#image-list {
  position: relative; /* Needed for Masonry's absolute positioning */
  margin: 0 auto;
  max-width: 1200px; /* or whatever width you want for your gallery */
}



    /* Each image-card is one Masonry 'tile' or 'brick'. */
    .image-card {
      /* Match the width to .grid-sizer if you want uniform columns. */
      width: 25%;
      float: left; /* Masonry can handle floats or you can omit float if you prefer. */
      box-sizing: border-box;
      padding: 8px;
      margin-bottom: 16px;
      background-color: #2d3748; /* Example background */
      border-radius: 8px;
      position: relative; /* for the like button absolute positioning */
    }

    .image-card img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 8px;
    }
      
      
/* Default: small screens (< 400px) => 1 column or 2 columns */
.grid-sizer,
.image-card {
  width: 50%; /* 2 columns by default */
}

/* If the screen is at least 400px wide => 2 columns might become 50% still, or you can do 2 columns default and skip this */
@media (min-width: 400px) {
  .grid-sizer,
  .image-card {
    width: 50%; /* 2 columns */
  }
}

/* If at least 600px => 3 columns */
@media (min-width: 600px) {
  .grid-sizer,
  .image-card {
    width: 33.33%; /* 3 columns */
  }
}

/* If at least 900px => 4 columns */
@media (min-width: 900px) {
  .grid-sizer,
  .image-card {
    width: 25%; /* 4 columns */
  }
}

/* If at least 1200px => 5 columns */
@media (min-width: 1200px) {
  .grid-sizer,
  .image-card {
    width: 20%; /* 5 columns */
  }
}


      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
     /* Center the button on normal screens */
.down-arrow-button {
  display: flex;
  justify-content: center; /* Center the button */
}

/* Mobile adjustments */
@media (max-width: 640px) {
  /* Ensure the parent container is a flex container */
  .down-arrow-button {
    display: flex;
    justify-content: flex-end; /* Move the button to the right */
    width: 100%; /* Ensure it takes full width */
    padding-right: 16px; /* Add some spacing from the edge */
  }
} 
      
/* Add this to your existing styles */
#prompt-status-text {
  position: absolute;
  top: 16px; /* Adjust as needed */
  left: 16px; /* Moved to the left side */
  font-size: 1rem; /* Larger font size */
  font-weight: 600; /* Bolder text */
  color: #9CA3AF; /* Light gray color */
  transition: color 0.2s, left 0.2s; /* Smooth transitions for color and position */
}

#prompt-status-text.red {
  color: #EF4444; /* Tailwind's text-red-500 */
  left: 135px; /* Move closer to the prompt input when thumbnail is present */
}

/* Mobile adjustments */
@media (max-width: 640px) {
  #prompt-status-text.red {
    left: 30px; /* Keep the text in its original position on small screens */
  }
}      
      
 /* Thumbnail Image */
.thumbnail-image {
  width: 5rem; /* Default size */
  height: 5rem;
  border-radius: 0.5rem;
  object-fit: cover;
}

/* Mobile adjustments */
@media (max-width: 640px) {
  .thumbnail-image {
    width: 3rem; /* Smaller size for mobile */
    height: 3rem;
  }
}     
      
      
      
      
  </style>
</head>
<body class="bg-gray-900 text-white">
    
 <!-- Navbar -->
<nav class="bg-gray-800 shadow-md fixed top-0 left-0 right-0 z-50">
  <div class="container mx-auto px-2 py-2 flex justify-between items-center">
    
    <!-- Left Section: Hamburger Menu and Logo -->
    <div class="flex items-center space-x-4">
      
      <!-- Logo -->
      <!-- Logo as a Button -->
        <button id="logo-button" class="flex items-center space-x-2 focus:outline-none">
          <img src="/images/logo.png" alt="Pixzor Logo">
          <span class="text-lg sm:text-xl font-bold">Pixzor</span>
        </button>
    </div>

    <!-- Right Section: Mobile-friendly Buttons -->
    <div class="flex items-center space-x-2 sm:space-x-4">
      <button id="tokens-button" class="flex items-center bg-gray-700 hover:bg-yellow-600 px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 text-yellow-400 mr-1 sm:mr-2" viewBox="0 0 20 20" fill="currentColor">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
          <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM10 18a8 8 0 100-16 8 8 0 000 16z" clip-rule="evenodd" />
        </svg>
        <span id="token-count" class="text-yellow-400">- Tokens</span>
      </button>

      <button id="google-auth-button" class="flex items-center bg-gray-700 hover:bg-green-600 px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
  <div class="w-4 h-4 sm:w-6 sm:h-6 mr-1 sm:mr-2 rounded-full bg-gray-600 flex items-center justify-center">
    <i class="fas fa-user text-white text-xs sm:text-sm"></i> <!-- FontAwesome user icon -->
  </div>
  <span>Login</span>
</button>
        
    </div>
  </div>
</nav>


  
<!-- Filter Sidebar -->
<div id="filter-sidebar" class="fixed left-0 top-0 h-full w-64 bg-gray-800 text-white p-4 hidden">
  <!-- Backdrop -->
  <div id="sidebar-backdrop" class="fixed inset-0 bg-black bg-opacity-50 z-4999 hidden"></div>

  <!-- Close Button -->
  <button id="close-sidebar" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600 text-2xl" aria-label="Close">
    &times;
  </button>

  <!-- Sidebar Content -->
  <h2 class="text-lg font-bold mb-4">Filters</h2>
  
  <!-- Image Source -->
  <h3 class="text-md font-semibold mb-2">Image Source</h3>
  <ul class="mb-4">
    <li>
      <button class="filter-button" data-category="image-source" data-filter="ai-generated">AI Generated</button>
    </li>
    <li>
      <button class="filter-button" data-category="image-source" data-filter="user-uploaded">User Uploaded</button>
    </li>
    <li>
      <button class="filter-button" data-category="image-source" data-filter="stylized-photo">Stylized Photos</button>
    </li>
  </ul>
    
  <!-- Advanced Filters -->
  <h3 class="text-md font-semibold mb-2">Advanced Filters</h3>
  <ul>
    <li>
      <button class="filter-button" data-category="advanced" data-advanced="newest">Newest</button>
    </li>
    <li>
      <button class="filter-button" data-category="advanced" data-advanced="most-liked">Most Liked</button>
    </li>
    <li>
      <button class="filter-button" data-category="advanced" data-advanced="most-commented">Most Commented</button>
    </li>
    <li>
      <button class="filter-button" data-category="advanced" data-advanced="trending">Trending</button>
    </li>
  </ul>    

  <!-- AI Subcategories -->
  <h3 class="text-md font-semibold mb-2">Styles</h3>
  <ul class="menu-style-list mb-4"></ul>  
    
  <!-- Close Button at the Bottom (Optional) -->
  <button id="close-sidebar-bottom" class="mt-8 bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded">
    Close
  </button>
</div>

    

    
    
<!-- Fixed Container for Toggle Buttons -->
<div class="fixed left-0 right-0 z-40 " style="top: 56px;">
  <div class="container mx-auto py-2 flex items-center">
    <!-- Open Filters Button (aligned to the left) -->
    <div class="flex-grow">
      <button 
        id="open-filters-button" 
        class="bg-gray-700 hover:bg-green-600 text-white text-sm px-4 py-2 rounded-lg shadow-md flex items-center space-x-2">
        <i class="fas fa-filter"></i>
        <span>Open Filters</span>
      </button>
    </div>

   <div class="flex justify-center flex-grow">
  <button id="public-toggle" class="custom-button bg-transparent text-white px-4 rounded-l-lg text-sm selected-toggle hover:bg-green-700">
    Public Posts
  </button>

  <button id="profile-toggle" class="custom-button bg-transparent text-white px-4 rounded-r-lg text-sm hover:bg-green-700">
    Profile Posts
  </button>
  
  <button id="search-results-toggle" class="custom-button bg-transparent text-white px-4 rounded-r-lg text-sm hover:bg-green-700 hidden">
    Search Results
  </button>
</div>    
    <!-- Empty space on the right (optional for future elements) -->
    <div class="flex-grow"></div>
  </div>
</div>




<!-- Main Container -->
<div class="container mx-auto py-20 content-padding">
  <!-- Error Message -->
  <div id="error-message" class="text-red-500 text-center mb-4"></div>

  <!-- User Profile Container -->
  <div id="profile-container">
    <!-- User Profile Header -->
    <div class="flex items-center space-x-4 mb-8">
      <img id="profile-avatar" src="" alt="User Avatar" class="w-16 h-16 rounded-full hidden"  referrerPolicy="no-referrer" >
      <h1 id="profile-username" class="text-2xl font-bold"></h1>
    </div>

   <!-- Masonry Container (replaces the old "image-list" in your snippet) -->
  <div id="image-list">
    <!-- .grid-sizer is required for fluid Masonry column width -->
    <div class="grid-sizer"></div>
    <!-- Items will be dynamically appended here by loadImages() -->
  </div>

  <!-- Include imagesLoaded and Masonry via CDN -->
  <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
      
  </div>
</div>

    
    
    
    
<div class="fixed-prompt bottom-action-bar">
  <button class="large-button" onclick="showUploadImage()">
    <i class="fas fa-upload"></i> Upload
  </button>
  <button class="large-button" onclick="showCreateImage()">
    <i class="fas fa-paint-brush"></i> Create
  </button>
  <button class="large-button" onclick="showSearchImages()">
    <i class="fas fa-search"></i> Search
  </button>
</div>

    

<!-- Image Upload Section -->
<div id="image-upload" class="hidden">
  <div class="upload-container">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-white text-lg">Upload Your Image</h2>
      <button onclick="returnToMain()" class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-green-600">
        Back
      </button>
    </div>
    <form id="image-upload-form" enctype="multipart/form-data">
      <input
        type="file"
        id="image-file"
        name="image"
        accept="image/*"
        class="block w-full text-sm text-white bg-gray-700 border border-gray-300 rounded-lg cursor-pointer focus:outline-none"
        required
      />
      <textarea
        id="image-description"
        name="description"        
        rows="3"
        class="mt-4 block w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-300"
        placeholder="Add a description (optional)"
      ></textarea>

      <!-- Conversion Information -->
      <div class="mt-4 p-4 bg-gray-800 rounded-lg text-sm text-white">
        <p class="font-medium">✨ Transform Your Image ✨</p>
        <p class="mt-2">
          After uploading, you can convert your image into different styles, such as paintings, sketches, or other artistic effects.
        </p>
      </div>

      <button
        type="submit"
        class="mt-4 bg-green-700 hover:bg-green-600 text-white font-medium px-4 py-2 rounded-lg text-sm"
      >
        Upload Image
      </button>
      <div class="mt-4 w-full bg-gray-700 rounded-lg h-2">
        <div id="upload-progress-bar" class="h-2 bg-blue-500 rounded-lg" style="width: 0;"></div>
      </div>
      <div id="upload-status" class="mt-2 text-sm text-white"></div>
    </form>
  </div>
</div>






<div id="ai-creation" class="hidden">
    <div class="fixed-prompt bg-gray-800 rounded-t-lg shadow-md">
      <div class="container mx-auto px-2 py-3">
        <!-- Add the new text element here -->
        <div id="prompt-status-text" class="absolute top-2 left-4 text-base font-semibold text-gray-400 transition-all duration-200">
          Generate an image
        </div>
        <!-- Main Content Area -->
        <div class="flex flex-col space-y-2">
          <!-- Down Arrow Button -->
          <div class="down-arrow-button">
            <button onclick="returnToMain()" class="bg-gray-700 hover:bg-green-600 text-white h-4 w-20 rounded-full my-1 flex items-center justify-center">
              <svg class="w-4 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
          </div>

          <!-- Thumbnail and Prompt Layout -->
          <div class="flex flex-row space-x-2 w-full">
            <div id="selected-thumbnail-container">
              <!-- Thumbnail will be inserted here -->
            </div>

            <!-- Textarea Container -->
            <div class="flex-grow relative min-w-0">
              <textarea
                id="prompt-input"
                class="w-full bg-gray-700 rounded-lg p-2 pr-24 text-sm text-white border border-gray-600 resize-none"
                rows="2"
                placeholder="Enter your prompt"
                aria-label="Prompt Input"
                style="width: 100%; box-sizing: border-box;"
              ></textarea>
            </div>
          </div>

          <!-- Controls Area -->
          <div class="flex flex-wrap gap-2 items-center">
            <!-- Options Button -->
            <button id="options-button" class="custom-button px-3" title="Options">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </button>

            <!-- Enhance Prompt Button -->
            <button id="enhance-prompt-button" class="custom-button px-3" title="Enhance Prompt">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
              </svg>
            </button>

          <!-- Aspect Ratio Dropdown -->
        <div class="custom-dropdown" id="aspect-ratio-select">
          <div class="selected-option">
            <i class="fas fa-crop-alt"></i>
            <span>1:1</span> <!-- Default to 1:1 -->
            <i class="fas fa-chevron-down"></i>
          </div>
          <ul class="dropdown-options">
            <li data-value="1:1">
              <i class="fas fa-square"></i>
              <span>1:1</span>
            </li>
            <li data-value="4:3">
              <i class="fas fa-image"></i>
              <span>4:3</span>
            </li>
            <li data-value="3:4">
              <i class="fas fa-image"></i>
              <span>3:4</span>
            </li>
            <li data-value="16:9">
              <i class="fas fa-desktop"></i>
              <span>16:9</span>
            </li>
            <li data-value="9:16">
              <i class="fas fa-mobile-alt"></i>
              <span>9:16</span>
            </li>
          </ul>
        </div>
            <!-- Style Dropdown -->
            <select id="style-select" class="custom-select">
              <option value="" disabled selected>Style</option>
            </select>

            <!-- Model Dropdown -->
            <select id="model-select" class="custom-select">
              <option value="" disabled selected>Model</option>
            </select>

            <!-- Group Visibility Button and Generate Button -->
            <div class="flex items-center gap-2 ml-auto">
              <!-- Generate Button -->
              <button id="generate-button" class="bg-green-700 hover:bg-green-600 text-white px-4 py-1 rounded-lg text-sm font-medium">
                <span class="generate-text">Generate</span>
                <span class="generate-icon">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                  </svg>
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    
    

<!-- Image Search Section -->
<div id="image-search" class="hidden">
  <div class="search-container">
    <div class="flex justify-between items-center w-full">
      <h2 class="text-white text-lg">Search for Images</h2>
      <button onclick="returnToMain()" class="bg-gray-700 text-white px-3 py-1.5 rounded hover:bg-green-600 text-sm">
        Back
      </button>
    </div>
    <!-- Search Input and Dropdown -->
    <div class="flex flex-col sm:flex-row gap-2 items-center mt-2 w-full">
      <input
        type="text"
        id="search-query"
        class="w-full sm:flex-grow bg-gray-700 text-white rounded-lg py-1.5 px-2 border border-gray-300 placeholder:text-sm"
        placeholder="Enter keywords to search"
      />
      <button
        id="search-button"
        class="w-full sm:w-auto bg-green-700 hover:bg-green-600 text-white font-medium px-3 py-1.5 rounded-lg text-sm"
      >
        Search
      </button>
    </div>
  </div>
</div>



<!-- Buy Tokens Modal -->
<div id="buy-tokens-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-100 text-gray-900 rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <!-- Close Button -->
      <button id="close-buy-tokens-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">
        &times;
      </button>

      <!-- Modal Header -->
      <h2 class="text-xl font-bold mb-4">Manage PIXZOR Tokens</h2>

      <!-- Token Purchase Form -->
      <form id="buy-tokens-form" class="mb-6">
        <label for="token-bundle" class="block mb-2">Select a Token Bundle:</label>
        <select id="token-bundle" class="w-full border rounded-lg p-2 mb-4 dropdown-menu">
          <option value="300" data-price="3.00">300 Tokens - £3.00</option>
          <option value="500" data-price="5.00">500 Tokens - £5.00</option>
          <option value="1200" data-price="10.00">1,200 Tokens - £10.00</option>
          <option value="3000" data-price="20.00">3,000 Tokens - £20.00</option>
          <option value="5000" data-price="30.00">5,000 Tokens - £30.00</option>
          <option value="20000" data-price="100.00">20,000 Tokens - £100.00</option>
        </select>
        <button type="submit" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-500">
          Purchase Tokens
        </button>
      </form>

      <!-- Support Email Section -->
      <div class="text-center text-sm text-gray-600">
        <p>Having issues with Tokens? Contact us at:</p>
        <a href="mailto:contact@pixzor.com" class="text-blue-500 hover:text-blue-700">contact@pixzor.com</a>
      </div>
    </div>
  </div>
</div>



<div id="options-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" aria-modal="true" aria-labelledby="options-modal-title">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-200 border-2 border-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="close-options-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">&times;</button>
      <h2 id="options-modal-title" class="text-xl font-bold mb-4 text-gray-900">Options</h2>

      <form id="options-form">
       
          <div class="flex items-center mt-2">
  <input type="checkbox" id="lock-aspect-ratio" class="mr-2" checked>
  <label for="lock-aspect-ratio" class="text-sm text-gray-900">Lock Aspect Ratio</label>
</div>
          
        <!-- Width Slider -->
        <div class="mb-4">
          <label for="width-slider" class="block font-medium mb-1 text-gray-900">Width</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="width-slider" min="256" max="1536" step="64" value="800" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600">
            <span id="width-value" class="text-sm text-gray-900">800</span>
          </div>
        </div>

        <!-- Height Slider -->
        <div class="mb-4">
          <label for="height-slider" class="block font-medium mb-1 text-gray-900">Height</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="height-slider" min="256" max="1536" step="64" value="600" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600">
            <span id="height-value" class="text-sm text-gray-900">600</span>
          </div>
        </div>

        <!-- Guidance Scale Slider -->
        <div class="mb-4">
          <label for="guidance-scale-modal" class="block font-medium mb-1 text-gray-900">Guidance Scale (0–20)</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="guidance-scale-modal" min="0" max="20" step="0.1" value="10" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600">
            <span id="guidance-scale-value" class="text-sm text-gray-900">10</span>
          </div>
        </div>

        <!-- Inference Steps Slider -->
        <div class="mb-4">
          <label for="inference-steps-modal" class="block font-medium mb-1 text-gray-900">Inference Steps (1–50)</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="inference-steps-modal" min="1" max="50" step="1" value="28" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600">
            <span id="inference-steps-value" class="text-sm text-gray-900">28</span>
          </div>
        </div>

        <!-- Image Strength Slider -->
        <div class="mb-4">
          <label for="image-strength-modal" class="block font-medium mb-1 text-gray-900">Image Strength</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="image-strength-modal" min="0" max="1" step="0.01" value="0.75" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600">
            <span id="image-strength-value" class="text-sm text-gray-900">0.75</span>
          </div>
        </div>

        <!-- Token Cost Display -->
        <div class="mb-4 flex justify-between items-center">
          <label class="block font-medium text-gray-900">Token Cost</label>
          <div id="token-cost-display" class="text-gray-900">
            <!-- Token cost will be dynamically updated here -->
          </div>
        </div>

        <!-- Reset and Save Buttons -->
        <div class="flex justify-between">
          <button type="button" id="reset-options" class="custom-button font-medium py-2 px-4 bg-gray-500 text-white rounded-lg hover:bg-gray-600">Reset</button>
          <button type="submit" class="custom-button font-medium py-2 px-4 bg-gray-700 text-white rounded-lg hover:bg-green-600">Save Options</button>
        </div>
      </form>
    </div>
  </div>
</div>
    

  <!-- Setup Character Modal -->
<div id="setup-character-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="setup-character-modal-title">
 
    <div class="flex items-center justify-center min-h-screen px-4">
      <div class="bg-gray-800 rounded-lg shadow-lg w-full max-w-md p-6 relative">
        <button id="close-setup-character-modal" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600" aria-label="Close">&times;</button>
        <h2 id="setup-character-modal-title" class="text-xl font-bold mb-4">Setup Character</h2>
        <form id="setup-character-form">
          <!-- Character Name -->
          <div class="mb-4">
            <label for="character-name" class="block font-medium mb-1">Character Name</label>
            <input type="text" id="character-name" name="character-name" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" required>
          </div>
          <!-- Character Description -->
          <div class="mb-4">
            <label for="character-description" class="block font-medium mb-1">Description</label>
            <textarea id="character-description" name="character-description" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" rows="4" placeholder="Describe your character"></textarea>
          </div>
          <!-- Upload Face -->
          <div class="mb-4">
            <label for="face-upload-character" class="block font-medium mb-1">Upload Face</label>
            <input type="file" id="face-upload-character" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white">
          </div>
          <div class="flex justify-end">
            <button type="submit" class="custom-button font-medium py-2 px-4 rounded-lg">Save Character</button>
          </div>
        </form>
      </div>
    </div>
  </div>
    
 
<!-- Comments Modal -->
<div id="comments-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50">
  <div class="bg-white rounded-lg shadow-lg flex flex-col md:flex-row relative w-11/12 md:w-4/5 max-h-screen overflow-y-auto">
    <!-- Close Button -->
 <button id="close-comments-modal" class="absolute top-2 right-2 bg-gray-400 text-white hover:bg-green-300 rounded-full p-1 text-2xl z-30" aria-label="Close Comments Modal">
  &times;
</button>


<!-- Left Section: Image -->
<div class="md:w-2/3 bg-gray-100 flex flex-col items-start p-4 relative">
  <!-- Fullscreen Icon -->
  <button id="fullscreen-icon" class="absolute top-2 left-2 bg-black text-white p-1 rounded-full text-sm z-20" aria-label="Fullscreen Image">
    <i class="fas fa-expand"></i>
  </button>

  <!-- Image -->
  <img id="modal-image" src="" alt="Full Image" class="w-full h-auto rounded-lg object-contain">

  <!-- Style and Model Information -->
  <div class="w-full mt-4 space-y-2">
    <!-- Style (with a container for dynamic hiding) -->
    <div id="style-container" class="flex flex-col hidden">
      <h3 class="text-sm font-semibold text-gray-700">Style</h3>
      <p id="modal-style" class="text-xs text-gray-500"></p>
    </div>

    <!-- Model (with a container for dynamic hiding) -->
    <div id="model-container" class="flex flex-col hidden">
      <h3 class="text-sm font-semibold text-gray-700">Model</h3>
      <p id="modal-model" class="text-xs text-gray-500"></p>
    </div>
  </div>
</div>

    <!-- Right Section: Details and Comments -->
    <div class="md:w-1/3 p-6 flex flex-col space-y-4">
      <!-- Prompt -->
      <div class="flex flex-col">
        <h3 class="text-lg font-bold text-black mb-2 flex items-center">
          Prompt
          <button id="copy-prompt" class="ml-2 text-gray-500 hover:text-gray-700" title="Copy Prompt" aria-label="Copy Prompt">
            <i class="fas fa-copy"></i>
          </button>
        </h3>
        <div id="modal-prompt-container" class="border p-3 rounded max-h-24 overflow-y-auto bg-gray-50 relative">
          <p id="modal-prompt" class="text-gray-600 pr-8"></p>
        </div>
      </div>

      <div class="flex items-center">
      <button id="like-button-modal" class="bg-gray-700 text-white p-2 rounded-full">
        <i class="fas fa-heart"></i>
      </button>
      <span id="like-count" class="ml-2 text-gray-600">0</span>
    </div>
    
      <!-- User Profile -->
      <div>
        <h3 class="text-lg font-bold text-black">Created By <a id="modal-user-profile" href="#" class="text-blue-500 hover:underline"></a></h3>    
      </div>
        
      

      <!-- Action Buttons with Icons and Tooltips -->
      <div class="flex flex-wrap gap-2">
          
        <div class="relative group">
          <a id="download-button" href="#" class="bg-green-600 text-white p-2 rounded flex items-center" download>
            <i class="fas fa-download"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Download</span>
        </div>
          
         <!-- Delete Button (Conditional) -->
        <div id="delete-button-container" class="relative group hidden">
          <button id="delete-button-modal" class="bg-red-600 text-white p-2 rounded flex items-center" aria-label="Delete Image">
            <i class="fas fa-trash"></i>
          </button>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Delete</span>
        </div>  
          
          
        <div class="relative group">
          <a id="create-button" href="#" class="btn bg-purple-600 text-white p-2 rounded flex items-center" aria-label="Create Similar">
            <i class="fas fa-pencil-alt"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Create Similar</span>
        </div>
          
          
          
        <div class="relative group">
          <a id="share-facebook" href="#" target="_blank" class="bg-blue-600 text-white p-2 rounded flex items-center" aria-label="Share on Facebook">
            <i class="fab fa-facebook-f"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Facebook</span>
        </div>
          
          
          
        <div class="relative group">
          <a id="share-twitter" href="#" target="_blank" class="bg-blue-400 text-white p-2 rounded flex items-center" aria-label="Share on Twitter">
            <i class="fab fa-twitter"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Twitter</span>
        </div>
        <div class="relative group">
          <a id="share-pinterest" href="#" target="_blank" class="bg-red-600 text-white p-2 rounded flex items-center" aria-label="Share on Pinterest">
            <i class="fab fa-pinterest-p"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Pinterest</span>
        </div>
      </div>

      <!-- Comments Section -->
      <div class="flex flex-col flex-grow overflow-hidden">
        <h3 class="text-lg font-bold text-black mb-2">Comments</h3>
        <div class="flex-grow overflow-y-auto mb-4">
          <ul id="comments-list" class="space-y-2"></ul>
        </div>
        
        <!-- Comment Input at the Bottom -->
        <div class="mt-auto">
          <textarea id="comment-input" placeholder="Write a comment..." class="w-full p-2 border rounded text-black mb-2" aria-label="Write a comment"></textarea>
          <button id="post-comment" class="w-full bg-green-600 text-white px-4 py-2 rounded" aria-label="Post Comment">Post Comment</button>
        </div>
      </div>
    </div>
  </div>
</div>




<!-- Welcome Modal -->
<div id="welcome-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
  <div class="bg-gray-800 text-white rounded-lg shadow-lg p-6 max-w-md w-full">
    <h2 class="text-xl font-bold mb-4">Welcome to Pixzor!</h2>
    <p class="mb-4">
      Register now to claim your <strong>50 free tokens</strong> and start creating stunning AI-generated images.
    </p>
    <div class="flex justify-end space-x-4">
      <button id="close-welcome-modal" class="bg-gray-700 hover:bg-green-600 text-white px-4 py-2 rounded-lg">
        Close
      </button>
      <button id="register-with-google" class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded-lg">
        Register with Google
      </button>
    </div>
  </div>
</div>

<!-- About Popup -->
<div id="about-popup" class="hidden fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50">
  <div class="bg-gray-800 text-white rounded-lg shadow-lg p-6 max-w-md w-full">
    <h2 class="text-xl font-bold mb-4">About Pixzor</h2>
    <p class="mb-4">
      Pixzor is an AI-powered platform designed to help you create stunning, personalized images. 
      Upload a photo of yourself, and transform it into different styles or environments while maintaining 
      your unique face and body pose. This ensures <strong>character consistency</strong>, making it perfect 
      for storytelling. In the near future we also plane to provide <strong>AI-powered video animation.</strong>
    </p>

    <!-- Example link in the Footer -->
    <footer class="bg-gray-900 text-white p-4 text-center">
      <p>
        By using Pixzor, you agree to our 
      <a id="terms-link" href="#" class="text-blue-400 hover:text-blue-300">Terms of Service</a>.    
      </p>
    </footer>
      
    <p class="mb-4">
      For any inquiries, please contact us at: 
      <a href="mailto:contact@pixzor.com" class="text-blue-400 hover:text-blue-300">contact@pixzor.com</a>
    </p>
    <button id="close-about-popup" class="bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg">
      Close
    </button>
  </div>
</div>
    
    
<!-- New Popup with Iframe -->
<div id="iframe-popup" class="hidden fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50">
  <div class="bg-gray-800 text-white rounded-lg shadow-lg p-6 max-w-3xl w-full h-[80vh]">
    <h2 class="text-xl font-bold mb-4">Terms of Service</h2>
    <iframe 
      id="iframe-content" 
      src="/terms-of-service.html" 
      class="w-full h-[calc(100%-3rem)] border border-gray-700 rounded-lg"
      frameborder="0"
    ></iframe>
    <button id="close-iframe-popup" class="mt-4 bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg">
      Close
    </button>
  </div>
</div>
    
    
<!-- Fullscreen Modal -->
<div id="fullscreen-modal" class="hidden fixed inset-0 bg-black bg-opacity-90 flex justify-center items-center z-50">
  <div class="relative w-full h-full flex justify-center items-center">
    <!-- Fullscreen Image -->
    <img id="fullscreen-image" src="" alt="Full Image" class="max-w-full max-h-full object-contain">

    <!-- Close Button -->
    <button id="close-fullscreen-modal" class="absolute top-4 right-4 bg-red-500 hover:bg-red-600 text-white text-2xl px-3 py-1 rounded-full shadow-lg">
      &times;
    </button>
  </div>
</div>
    

  <!-- Toast Notification Container -->
  <div id="toast-container" class="fixed top-20 right-20 z-50"></div>

  <!-- JavaScript -->
  <script>
    // script.js
    let isPublic = false;
    let page = 1; // Initial page for pagination
    let isLoading = false; // Prevent multiple simultaneous requests      
    let msnry = null; // Reference the Masonry instance here:      
    let hasMoreImages = true; // Track if there are more images to load
    let selectedStyle = '';
    const selectedImages = new Set(); // Track selected images globally
    // The activeTab defaults to 'public'
    let activeTab = 'public';
    let isLoadingImages = false;

    let selectedImageState = {
      imageId: null,
      keepFace: false,
      keepStyle: false,
      keepPose: false,
    };

    window.isLoggedIn = <%= isLoggedIn %>; // Pass `true` or `false`
    window.currentUser = <%- JSON.stringify(user || {}) %>;
  
    if (!window.isLoggedIn) {
        console.log('User is not logged in');
    } else {
        console.log(`Welcome, ${window.currentUser.username}!`);
    }       
    let selectedFilters = {
      type: 'ai-generated', // Default value
      style: 'all-styles', // Default value
      sort: 'newest', // Default value
    };

  


      
      
  // Dynamically generated styles array
  const styles = <%- JSON.stringify(stylesWithCounts) %>;

      
function populateMenuStyles() {
  const menu = document.querySelector(".menu-style-list");
  if (!menu) {
    console.error("Menu element not found!");
    return;
  }

  menu.innerHTML = ""; // Clear existing items

  styles.forEach((style) => {
    const countDisplay = style.value === 'all-styles' ? style.count : style.count || 0;
    const li = document.createElement("li");
    li.innerHTML = `
      <button class="filter-button" data-category="art-styles" data-subfilter="${style.value}">
        ${style.label} (${countDisplay})
      </button>
    `;
    menu.appendChild(li);
  });

  // Add event listeners to the buttons
  const buttons = menu.querySelectorAll(".filter-button");
  buttons.forEach((button) => {
    button.addEventListener("click", (event) => {
      const filterCategory = event.target.dataset.category;
      const filterValue = event.target.dataset.subfilter;

      // Update filters
      activeFilters[filterCategory] = filterValue;
      
      // Apply filters
      applyFilters();
    });
  });
}




      
function populateAIStyleDropdown() {
  //const dropdown = document.getElementById("style-select-modal");
  const dropdown = document.getElementById("style-select");    
    
  if (dropdown) {
    dropdown.innerHTML = '<option value="" disabled selected>Choose a style</option>'; // Reset options
    styles.forEach((style) => {
      const option = document.createElement("option");
      option.value = style.value;
      option.textContent = style.label;
      dropdown.appendChild(option);
    });
  } 
}

function populateSearchStyles() {
  const dropdown = document.getElementById("category-select");
  if (dropdown) {
    dropdown.innerHTML = '<option value="" disabled selected>Choose a category</option>'; // Reset options
    styles.forEach((style) => {
      const option = document.createElement("option");
      option.value = style.value;
      option.textContent = style.label;
      dropdown.appendChild(option);
    });
  }
}
      


// Map each style to its default model
const styleToModelMap = {
  "abstract": "animagine-xl-v-3-1", // Artistic and flexible
  "anime": "sdvn7-niji-style-xl-v1", // Specialized for anime
  "balloon-art": "real-cartoon-xl-v6", // Best for cartoon-like visuals
  "cartoon": "real-cartoon-xl-v6", // Good for cartoon styles
  "ceramic": "stable-diffusion-xl-v1-0", // Use SD XL for versatility
  "chibi": "sdvn7-niji-style-xl-v1", // Specialized for anime and chibi
  "claymation": "animagine-xl-v-3-1", // Works great for claymation
  "comic": "real-cartoon-xl-v6", // Comic book-like visuals
  "crystal": "reproduction-v3-31", // Specialized for crystal-like details
  "cubist": "animagine-xl-v-3-1", // Works well for artistic styles
  "cyberpunk": "stable-diffusion-xl-v1-0", // Reliable alternative for cyberpunk
  "digital-art": "animagine-xl-v-3-1", // Good for digital art styles
  "dreamscape": "animagine-xl-v-3-1", // Artistic and dream-like
  "felted": "stable-diffusion-xl-v1-0", // SD XL works well for felted textures
  "graffiti": "real-cartoon-xl-v6", // Cartoonish and bold visuals
  "impressionist": "animagine-xl-v-3-1", // Works well for impressionist art
  "knitted-wool": "stable-diffusion-xl-v1-0", // Use SD XL for photorealistic knitting
  "metal-sculpture": "stable-diffusion-xl-v1-0", // Best for 3D textures
  "minimalist": "stable-diffusion-xl-v1-0", // SD XL for simplicity
  "mosaic": "animagine-xl-v-3-1", // Good for artistic mosaic-like visuals
  "neon-light": "real-cartoon-xl-v6", // Works for bright and cartoonish neon effects
  "oil-painting": "stable-diffusion-xl-v1-0", // SD XL is great for oil painting
  "origami": "reproduction-v3-31", // Best for delicate details
  "paper-cut": "real-cartoon-xl-v6", // Works for bold, graphic designs
  "photorealistic": "realvis-xl-v4", // Best for photorealism (updated to realvis-xl-v4)
  "photo": "realvis-xl-v4", // Reliable for photographic styles (updated to realvis-xl-v4)
  "pixar": "animagine-xl-v-3-1", // Best for Pixar-like effects
  "plant-based": "animagine-xl-v-3-1", // Flexible for plant-based styles
  "plush-toy": "animagine-xl-v-3-1", // Perfect for soft, plush visuals
  "quilted-fabric": "stable-diffusion-xl-v1-0", // SD XL for texture
  "sand-art": "animagine-xl-v-3-1", // Works for sand-like artistic visuals
  "stained-glass": "reproduction-v3-31", // Best for stained glass visuals
  "steampunk": "stable-diffusion-xl-v1-0", // SD XL for steampunk aesthetics
  "vaporwave": "real-cartoon-xl-v6", // Works for bold, vaporwave designs
  "vintage-poster": "real-cartoon-xl-v6", // Best for retro/vintage looks
  "watercolor": "animagine-xl-v-3-1", // Artistic and soft for watercolor
  "woodcarving": "stable-diffusion-xl-v1-0", // Best for 3D wood textures
};

// Function to close a modal
function closeModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.add('hidden');
    document.body.classList.remove('modal-open');
    document.body.classList.remove('overflow-hidden');
  }
}

      
      

// Track whether event listeners are already added
let fullscreenModalListenersAdded = false;

// Open Fullscreen Modal
// Open Fullscreen Modal
function openFullscreenModal(imageUrl) {
  const fullscreenModal = document.getElementById('fullscreen-modal');
  const fullscreenImage = document.getElementById('fullscreen-image');

  if (!fullscreenModal || !fullscreenImage) {
    console.error('Fullscreen modal or image element not found.');
    return;
  }

  // Set the image source
  fullscreenImage.src = imageUrl;

  // Show the modal
  fullscreenModal.classList.remove('hidden');

  // Reset zoom and position
  scale = 1;
  fullscreenImage.style.transform = `scale(${scale})`;

  // Add event listeners only if they haven't been added before
  if (!fullscreenModalListenersAdded) {
    // Close modal on button click
    const closeButton = document.getElementById('close-fullscreen-modal');
    closeButton.addEventListener('click', closeFullscreenModal);

    // Close modal on background or image click
    fullscreenModal.addEventListener('click', (event) => {
      // Check if the click is on the modal background or the image itself
      if (event.target === fullscreenModal || event.target === fullscreenImage) {
        closeFullscreenModal();
      }
    });

    // Handle orientation change
    window.addEventListener('orientationchange', handleOrientationChange);

    // Mark listeners as added
    fullscreenModalListenersAdded = true;
  }
}

// Close Fullscreen Modal
function closeFullscreenModal() {
  const fullscreenModal = document.getElementById('fullscreen-modal');
  const fullscreenImage = document.getElementById('fullscreen-image');

  if (!fullscreenModal || !fullscreenImage) {
    console.error('Fullscreen modal or image element not found.');
    return;
  }

  // Hide the modal
  fullscreenModal.classList.add('hidden');

  // Clear the image source to unload the image
  fullscreenImage.src = '';

  // Reset the image transform (zoom)
  fullscreenImage.style.transform = 'scale(1)';
}

// Utility function to introduce a delay
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
        
function switchTab(tab) {
  return new Promise((resolve, reject) => {
    page = 1;
    hasMoreImages = true;
    isLoadingImages = false;

    // Update activeTab
    activeTab = tab;

    // Clear out the Masonry container
    const imageList = document.getElementById('image-list');
    if (imageList) {
      imageList.innerHTML = '<div class="grid-sizer"></div>';
    }

    // Hide or clear the user profile elements
    const profileUsername = document.getElementById('profile-username');
    const profileAvatar = document.getElementById('profile-avatar');
    if (profileUsername) profileUsername.textContent = '';
    if (profileAvatar) {
      profileAvatar.src = '';
      profileAvatar.classList.add('hidden');
    }

    // Update button styles
    document.getElementById('public-toggle').classList.toggle('selected-toggle', activeTab === 'public');
    document.getElementById('profile-toggle').classList.toggle('selected-toggle', activeTab === 'profile');
    document.getElementById('search-results-toggle').classList.toggle('selected-toggle', activeTab === 'search');

    // Show/hide the search toggle if needed
    const searchResultsToggle = document.getElementById('search-results-toggle');
    if (activeTab === 'search') {
      searchResultsToggle.classList.remove('hidden');
    } else {
      searchResultsToggle.classList.add('hidden');
    }

    // Optionally destroy & re-init Masonry if you want a fresh layout
    if (msnry) {
      msnry.destroy();
    }
    const grid = document.getElementById('image-list');
    msnry = new Masonry(grid, {
      itemSelector: '.image-card',
      columnWidth: '.grid-sizer',
      percentPosition: true,
    });

    // Load content based on the active tab
    if (activeTab === 'public') {
      // Reset filters & load
      activeFilters['image-source'] = 'ai-generated';
      activeFilters['art-styles'] = 'all-styles';
      activeFilters['advanced'] = 'newest';
      applyFilters(); // or directly call loadImages for public
      resolve(); // Resolve immediately since applyFilters is synchronous
    } else if (activeTab === 'profile') {
      // Check if user is logged in
      fetch('/user-data')
        .then((res) => res.json())
        .then((userData) => {
          if (!userData.loggedIn) {
            showToast('Please log in to view your posts.', 'error');
            reject(new Error('User not logged in')); // Reject if user is not logged in
            return;
          }
          loadPrivatePosts().then(resolve).catch(reject); // Resolve when loadPrivatePosts is done
        })
        .catch((err) => {
          console.error('Error fetching user data:', err);
          showToast('An error occurred. Please try again.', 'error');
          reject(err); // Reject if there's an error
        });
    } else if (activeTab === 'search') {
      const query = document.getElementById('search-query').value.trim();
      if (query) {
        triggerSearch().then(resolve).catch(reject); // Resolve when triggerSearch is done
      } else {
        resolve(); // Resolve immediately if no query
      }
    } else {
      resolve(); // Resolve for any other case
    }
  });
}



// Helper function to retrieve model name from ID
function getModelLabel(modelId) {
  const modelList = {
    "sdvn7-niji-style-xl-v1": "SDVN7 NijiStyle XL", // Good for anime and chibi
    "real-cartoon-xl-v6": "RealCartoonXL v6", // Good for cartoon and comic styles
    "animagine-xl-v-3-1": "Animagine XL v3.1", // Good for artistic and digital art styles
    "reproduction-v3-31": "Reproduction v3.31", // Good for crystal, origami, and stained glass
    "stable-diffusion-xl-v1-0": "Stable Diffusion XL v1", // Good for oil painting, ceramic, and photorealistic textures
    "realvis-xl-v4": "RealVis XL v4", // Best for photo-realistic images
    "juggernaut-xl-v10": "Juggernaut XL v10", // Good for versatile and high-quality outputs
    "counterfeit-xl-v2-5": "Counterfeit XL v2.5", // Good for cartoonish and stylized visuals
  };
  return modelList[modelId] || "Unknown Model";
}

function populateInitialModelDropdown() {
  const modelDropdown = document.getElementById("model-select");

  if (modelDropdown) {
    modelDropdown.innerHTML = ""; // Reset the dropdown

    // Define the available models, organized into categories
    const models = [
      // High-Quality Models
      { id: "flux-dev", label: "FLUX DEV (High Quality)" },
      { id: "flux-schnell", label: "FLUX Schnell (High Quality)" },
      { id: "realvis-xl-v4", label: "RealVis XL v4 (Photo-Realistic)" },
      { id: "juggernaut-xl-v10", label: "Juggernaut XL v10 (Versatile)" },

      // General-Purpose Models
      { id: "stable-diffusion-xl-v1-0", label: "Stable Diffusion XL (General)" },
      { id: "animagine-xl-v-3-1", label: "Animagine XL v3.1 (Artistic)" },
      { id: "reproduction-v3-31", label: "Reproduction v3.31 (Detailed)" },

      // Specialized Models
      { id: "real-cartoon-xl-v6", label: "RealCartoon XL v6 (Cartoon)" },
      { id: "sdvn7-niji-style-xl-v1", label: "SDVN7 NijiStyle XL (Anime)" },
      { id: "counterfeit-xl-v2-5", label: "Counterfeit XL v2.5 (Stylized)" },
    ];

    // Populate the dropdown with the models
    models.forEach((model, index) => {
      const option = document.createElement("option");
      option.value = model.id;
      option.textContent = model.label;

      // Auto-select the first model as default
      if (index === 0) {
        option.selected = true;
      }

      modelDropdown.appendChild(option);
    });
  }
}

function resetStylesToAllStyles() {
  const styleDropdown = document.getElementById('style-select');
  
  if (styleDropdown) {
    // Reset the dropdown to the first option (placeholder: "Select a style")
    styleDropdown.selectedIndex = 0;

    // Trigger the change event to update the model dropdown accordingly
    const event = new Event('change');
    styleDropdown.dispatchEvent(event);
  }
}



function populateModelDropdownForImageSelection(selectedStyle, isImageSelected = false) {
  const modelDropdown = document.getElementById('model-select');

  if (!modelDropdown) {
    console.error('Model dropdown not found.');
    return;
  }

  // Clear the dropdown
  modelDropdown.innerHTML = "";

  // If no image is selected, default to Flux models
  if (!isImageSelected) {
    const fluxModels = [
      { id: "flux-dev", label: "FLUX DEV (High Quality)" },
      { id: "flux-schnell", label: "FLUX Schnell (High Quality)" },
        
      { id: "stable-diffusion-xl-v1-0", label: "Stable Diffusion XL (General)" },
      { id: "real-cartoon-xl-v6", label: "RealCartoonXL v6 (Cartoon/Artistic)" },
      { id: "sdvn7-niji-style-xl-v1", label: "SDVN7 NijiStyle XL (Anime)" },
      { id: "animagine-xl-v-3-1", label: "Animagine XL v3.1 (Claymation/Artistic)" },
      { id: "reproduction-v3-31", label: "Reproduction v3.31 (Crystal/Origami)" },
      { id: "realvis-xl-v4", label: "RealVis XL v4 (Photo-Realistic)" },
      { id: "juggernaut-xl-v10", label: "Juggernaut XL v10 (Versatile)" },
      { id: "counterfeit-xl-v2-5", label: "Counterfeit XL v2.5 (Stylized)" },

    ];

    fluxModels.forEach((model) => {
      const option = document.createElement("option");
      option.value = model.id;
      option.textContent = model.label;
      modelDropdown.appendChild(option);
    });

    // Auto-select the first Flux model
    if (fluxModels.length > 0) {
      modelDropdown.value = fluxModels[0].id;
    }

    return;
  }
  /*
  // If an image is selected, proceed with the original logic
  if (!selectedStyle || selectedStyle.toLowerCase() === "all-styles" || selectedStyle.toLowerCase() === "select-a-style") {
    populateInitialModelDropdown(); // Populate with the full list of models
    return;
  }*/

  // Add the recommended model for the selected style
  const defaultModelId = styleToModelMap[selectedStyle];
  if (defaultModelId) {
    const defaultOption = document.createElement("option");
    defaultOption.value = defaultModelId;
    defaultOption.textContent = getModelLabel(defaultModelId) + " (Recommended)";
    defaultOption.selected = true; // Auto-select the recommended model
    modelDropdown.appendChild(defaultOption);
  }

  // Add models that support image-to-image operations
  const imageToImageCompatibleModels = [
    { id: "stable-diffusion-xl-v1-0", label: "Stable Diffusion XL (General)" },
    { id: "real-cartoon-xl-v6", label: "RealCartoonXL v6 (Cartoon/Artistic)" },
    { id: "sdvn7-niji-style-xl-v1", label: "SDVN7 NijiStyle XL (Anime)" },
    { id: "animagine-xl-v-3-1", label: "Animagine XL v3.1 (Claymation/Artistic)" },
    { id: "reproduction-v3-31", label: "Reproduction v3.31 (Crystal/Origami)" },
    { id: "realvis-xl-v4", label: "RealVis XL v4 (Photo-Realistic)" },
    { id: "juggernaut-xl-v10", label: "Juggernaut XL v10 (Versatile)" },
    { id: "counterfeit-xl-v2-5", label: "Counterfeit XL v2.5 (Stylized)" },
  ];

  imageToImageCompatibleModels.forEach((model) => {
    if (model.id !== defaultModelId) { // Avoid duplicating the recommended model
      const option = document.createElement("option");
      option.value = model.id;
      option.textContent = model.label;
      modelDropdown.appendChild(option);
    }
  });
}




      
      
    document.addEventListener('DOMContentLoaded', () => {
      populateMenuStyles();       
      populateAIStyleDropdown();
      populateInitialModelDropdown();
      populateSearchStyles();

      // Fetch user data on page load
      fetchUserData();

      // Initialize character dropdown
      populateCharacterDropdown();

      // Set up event listeners
      setupEventListeners();

      const grid = document.getElementById('image-list');

      // Initialize Masonry
      msnry = new Masonry(grid, {
        itemSelector: '.image-card',  // each "tile" has this class
        columnWidth: '.grid-sizer',   // base column width
        percentPosition: true         // let Masonry treat columnWidth as percent
      });

      // Ensure Masonry does an initial layout after everything visible loads
      imagesLoaded(grid, () => {
        msnry.layout();
      });

      // Add a resize listener to re-layout Masonry on screen size changes
      window.addEventListener('resize', () => {
        const gridSizer = document.querySelector('.grid-sizer');
        if (gridSizer) {
          // Ensure the grid-sizer width matches the current CSS media query
          const gridSizerComputedStyle = getComputedStyle(gridSizer);
          gridSizer.style.width = gridSizerComputedStyle.width;

          // Trigger Masonry layout recalculation
          msnry.layout();
        }
      });

      // Check if the current page is a user profile page
      const path = window.location.pathname;
      const profileUserId = path.startsWith('/user-profile/') ? path.split('/')[2] : null;

      if (profileUserId) {
        // Load the user's profile images
        loadUserProfile(profileUserId);
      } else {
          // Load the first page from your API and fill the viewport
          const firstEndpoint = `/api/public-posts?type=ai-generated&page=1&`;
          loadImages(firstEndpoint, 'public', true); // Pass isInitialLoad = true
      }
        
    });


      
      
// Function to show the image upload prompt box
function hideAllSections() {
  const sections = ['image-upload', 'ai-creation', 'image-search'];
  sections.forEach(section => {
    const element = document.getElementById(section);
    element.classList.remove('visible');
    element.classList.add('hidden');
  });
}

      

function toggleActionBar(hide = true) {
  const actionBar = document.querySelector('.fixed-prompt.bottom-action-bar');
  if (hide) {
    actionBar.classList.add('hidden');
  } else {
    actionBar.classList.remove('hidden');
  }
}

function showUploadImage() {
  hideAllSections();
  toggleActionBar(true); // Hide the action bar
  const imageUploadDiv = document.getElementById("image-upload");
  imageUploadDiv.classList.remove('hidden');
  imageUploadDiv.classList.add('visible');
}

function showCreateImage() {
  hideAllSections();
  toggleActionBar(true); // Hide the action bar
  const imageUploadDiv = document.getElementById("ai-creation");
  imageUploadDiv.classList.remove('hidden');
  imageUploadDiv.classList.add('visible');
}

function showSearchImages() {
  hideAllSections();
  toggleActionBar(true); // Hide the action bar
  const imageUploadDiv = document.getElementById("image-search");
  imageUploadDiv.classList.remove('hidden');
  imageUploadDiv.classList.add('visible');
}

function returnToMain() {
  hideAllSections();
  toggleActionBar(false); // Show the action bar
}


    
async function toggleLike(imageId, likeButton) {
  const isLiked = likeButton.querySelector('i').classList.contains('liked');

  try {
    const response = await fetch(`/api/like/${imageId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        liked: !isLiked, // Toggle the liked state
      }),
    });

    if (response.ok) {
      const data = await response.json();

      // Toggle the "liked" class
      likeButton.querySelector('i').classList.toggle('liked', !isLiked);

      // Update the like count (if applicable)
      const likeCountElement = likeButton.nextElementSibling;
      if (likeCountElement && data.likes !== undefined) {
        likeCountElement.textContent = `${data.likes}`;
      }

      showToast(!isLiked ? 'Liked!' : 'Unliked!', 'success');
    } else {
      const errorData = await response.json();
      console.error('Failed to like the image:', errorData);
      showToast(errorData.error || 'Failed to like the image.', 'error');
    }
  } catch (error) {
    console.error('Error liking the image:', error);
    showToast('An error occurred while liking the image.', 'error');
  }
}



async function loadUserProfile(userId) {
  try {
    // Set the active tab to 'profile'
    activeTab = 'profile';

    // Close comments modal if it is open
    const commentsModal = document.getElementById('comments-modal');
    if (!commentsModal.classList.contains('hidden')) {
      commentsModal.classList.add('hidden'); // Hide the modal
      history.pushState(null, '', window.location.origin);
    }

    // Fetch user data
    const response = await fetch(`/api/user-profile/${userId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch user profile.');
    }

    const { user, publicImages } = await response.json();

    // Render user info
    const profileUsername = document.getElementById('profile-username');
    const profileAvatar = document.getElementById('profile-avatar');
    profileUsername.textContent = user.username;
    profileAvatar.src = user.photo || '/default-avatar.png'; // Fallback to default avatar
    profileAvatar.classList.remove('hidden');

    // Clear the image list
    const imageList = document.getElementById('image-list');
    imageList.innerHTML = '<div class="grid-sizer"></div>';

    // Use the loadImages function to render the user's public images
    const apiEndpoint = `/api/user-profile/${userId}`;
    loadImages(apiEndpoint, 'profile', true); // Pass isInitialLoad = true
  } catch (error) {
    console.error('Error loading user profile:', error);
    showToast('Failed to load user profile.', 'error');
  }
}

      
      
   function updateShareLinks(imageId, source) {
      const baseUrl = window.location.origin;
      const modalUrl = `${baseUrl}/?image=${imageId}&source=${source}`;
      const shareText = 'Check out this amazing AI-generated image!';

      document.getElementById('share-facebook').href = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(modalUrl)}`;
      document.getElementById('share-twitter').href = `https://twitter.com/intent/tweet?url=${encodeURIComponent(modalUrl)}&text=${encodeURIComponent(shareText)}`;
      document.getElementById('share-pinterest').href = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(modalUrl)}&media=${encodeURIComponent(modalUrl)}&description=${encodeURIComponent(shareText)}`;
    }



    function updateBrowserHistory(imageId, source) {
      history.pushState(null, '', `/?image=${imageId}&source=${source}`);
    }
      
    function setupComments(imageId) {
      
      // Use imageId to fetch and post comments
      // Update the global or modal-scoped variable to keep track of imageId
      window.currentImageId = imageId;

      // Fetch comments
      loadComments(imageId);
    }  


  function openCommentsModal(imageId, imageUrl, source) {
    // Set the current image ID globally
    window.currentImageId = imageId;
    const modalImage = document.getElementById('modal-image');
    const modalPrompt = document.getElementById('modal-prompt');
    const modalUserProfile = document.getElementById('modal-user-profile');
    const downloadButton = document.getElementById('download-button');
    const modalStyle = document.getElementById('modal-style');
    const modalModel = document.getElementById('modal-model');
    const deleteButtonContainer = document.getElementById('delete-button-container');
    const deleteButtonModal = document.getElementById('delete-button-modal');
    const styleContainer = document.getElementById('style-container'); // Container for style
    const modelContainer = document.getElementById('model-container'); // Container for model

    // Set image and download link
    modalImage.src = imageUrl;
    downloadButton.href = imageUrl;
    downloadButton.download = `image-${imageId}.jpg`;

    // Fetch image details
    fetch(`/api/image-details/${imageId}`)
      .then(response => response.json())
      .then(data => {
        // Update modal content
        modalPrompt.textContent = data.prompt || 'No prompt available.';
        modalUserProfile.textContent = data.username || 'Unknown User';
        modalUserProfile.href = `/user-profile/${data.userId}`;
        document.getElementById('like-count').textContent = data.likes || 0;

        // Handle style display
        if (data.style) {
          modalStyle.textContent = data.style;
          styleContainer.classList.remove('hidden'); // Show the style section
        } else {
          styleContainer.classList.add('hidden'); // Hide the style section
        }

        // Handle model display
        if (data.model) {
          modalModel.textContent = data.model;
          modelContainer.classList.remove('hidden'); // Show the model section
        } else {
          modelContainer.classList.add('hidden'); // Hide the model section
        }

      // Handle like button
      const likeButton = document.getElementById('like-button-modal');
      if (data.isLiked) likeButton.classList.add('liked');

      likeButton.addEventListener('click', () => {
        const liked = !likeButton.classList.contains('liked');
        likeButton.classList.toggle('liked', liked);

        // Send like toggle request
        fetch(`/api/like/${imageId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ liked, isPublic: data.isPublic }),
        })
          .then(response => response.json())
          .then(update => {
            document.getElementById('like-count').textContent = update.likes;
          })
          .catch(error => {
            console.error('Error toggling like:', error);
          });
      });

      // Show/hide delete button based on ownership
      if (data.isOwner) {
        deleteButtonContainer.classList.remove('hidden'); // Show delete button
        deleteButtonModal.setAttribute('data-id', imageId); // Set image ID for deletion
      } else {
        deleteButtonContainer.classList.add('hidden'); // Hide delete button
      }
    })
    .catch(error => {
      console.error('Error fetching image details:', error);
      showToast('Failed to load image details.', 'error');
    });

  // Update share links and browser history
  updateShareLinks(imageId, source);
  updateBrowserHistory(imageId, source);

  // Handle public/private image IDs for comments
  if (source === 'public') {
    fetch(`/api/public-image-details/${imageId}`)
      .then(response => response.json())
      .then(data => {
        const personalImageId = data.personalImageId;
        setupComments(personalImageId);
      })
      .catch(error => {
        console.error('Error fetching image details:', error);
        showToast('Failed to load image details.', 'error');
      });
  } else {
    setupComments(imageId);
  }

  // Show the modal
  document.getElementById('comments-modal').classList.remove('hidden');
}
      
      
    
    // Function to fetch user data
    async function fetchUserData() {
      try {
        const response = await fetch('/user-data');
        const data = await response.json();

        const tokenCountElement = document.getElementById('token-count');
        const googleAuthButton = document.getElementById('google-auth-button');

        if (data.loggedIn) {
          // Format token count: round to 1 or 2 decimal places
          const tokens = parseFloat(data.tokens);
          const formattedTokens = tokens.toFixed(1); // Use toFixed(2) for 2 decimal places

          // Update the token count for logged-in users
          tokenCountElement.textContent = `${formattedTokens} Tokens`;

          // Update the Google Auth button to show user info
          googleAuthButton.innerHTML = `
            <img src="${data.photo}" alt="Profile" class="mr-2 w-6 h-6 rounded-full" />
            <span>${data.username}</span>
          `;
          googleAuthButton.classList.remove('bg-gray-700');
          googleAuthButton.classList.add('bg-green-600');

          // Enable the generate button
          document.getElementById('generate-button').disabled = false;
        } else {
          // User is not logged in
          tokenCountElement.textContent = `- Tokens`; // Show "- Tokens" for unauthenticated users
          googleAuthButton.innerHTML = 'Login';
          googleAuthButton.classList.remove('bg-green-600');
          googleAuthButton.classList.add('bg-gray-700');

          // Disable the generate button
          //document.getElementById('generate-button').disabled = true;
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
        showToast('An error occurred while fetching user data.', 'error');
      }
    }

    function applyFilter(type, style, sort) {
      const apiEndpoint = `/api/public-posts?type=${type}&style=${style}&sort=${sort}`;
      page = 1; // Reset pagination
      hasMoreImages = true;
      document.getElementById('image-list').innerHTML = ''; // Clear previous results
      loadImages(apiEndpoint, 'public');
    }

  

    // Function to set up all event listeners
    function setupEventListeners() {
          
        const modalImage = document.getElementById('modal-image');
    
        document.getElementById('logo-button').addEventListener('click', () => {
          document.getElementById('about-popup').classList.remove('hidden');
        });

        // Close popup when clicking outside
        document.getElementById('about-popup').addEventListener('click', (e) => {
          if (e.target === document.getElementById('about-popup')) {
            document.getElementById('about-popup').classList.add('hidden');
          }
        });
        
        // Open the iframe popup (e.g., when clicking a "Terms of Service" link)
        document.getElementById('terms-link').addEventListener('click', () => {
          document.getElementById('iframe-popup').classList.remove('hidden');
        });

        // Close the iframe popup when clicking the close button
        document.getElementById('close-iframe-popup').addEventListener('click', () => {
          document.getElementById('iframe-popup').classList.add('hidden');
        });

        // Close the iframe popup when clicking outside
        document.getElementById('iframe-popup').addEventListener('click', (e) => {
          if (e.target === document.getElementById('iframe-popup')) {
            document.getElementById('iframe-popup').classList.add('hidden');
          }
        });

        // Handle style selection      
        document.getElementById('style-select').addEventListener('change', (event) => {
          const selectedStyle = event.target.value;

            
          // Normalize the value to lowercase for comparison
          if (!selectedStyle || selectedStyle.toLowerCase() === "all-styles" || selectedStyle.toLowerCase() === "select-a-style") {
            // Default back to Flux model when no specific style is selected
            populateModelDropdownForImageSelection(""); // Pass an empty string to trigger the Flux model
          } else {
            // Populate the model dropdown based on the selected style
            populateModelDropdownForImageSelection(selectedStyle);
          }
        });
        
        
        const deleteButtonModal = document.getElementById('delete-button-modal');
        if (deleteButtonModal) {
          deleteButtonModal.addEventListener('click', async (event) => {
            event.stopPropagation();
            const imageId = deleteButtonModal.getAttribute('data-id');

            // Show confirmation dialog
            const isConfirmed = confirm('Are you sure you want to delete this image?');
            if (!isConfirmed) {
              return; // Stop if the user cancels
            }

            try {
              // Close the comments modal
              closeModal('comments-modal');

              // Send delete request
              const response = await fetch('/delete-private-image/' + imageId, { method: 'DELETE' });
              if (response.ok) {
                showToast('Image deleted successfully!', 'success');

                // Remove the image card from the gallery
                const imageCard = document.querySelector(`[data-id="${imageId}"]`);
                if (imageCard) {
                  // Notify Masonry about the element removal
                  msnry.remove(imageCard);

                  // Recalculate the layout to fill the gap
                  msnry.layout();

                  // Remove the card from the DOM
                  imageCard.remove();

                  // Clean up any references to the deleted image
                  selectedImages.delete(imageId);

                  // Reload the gallery to reflect the changes
                  switchTab('profile');
                    
                } else {
                  console.warn('Image card not found');
                }
              } else {
                showToast('Failed to delete image', 'error');
              }
            } catch (error) {
              console.error('Error deleting image:', error);
              showToast('An error occurred while deleting the image', 'error');
            }
          });
        }

 

        // Add functionality for filter buttons
   document.querySelectorAll('.filter-button').forEach((button) => {
  button.addEventListener('click', (event) => {
    const filterCategory = event.target.dataset.category; // e.g., "image-source", "art-styles", "advanced"
    const filterValue = event.target.dataset.filter; // Value of the filter clicked, e.g., "ai-generated"

    // Update the selectedFilters object
    if (filterCategory === 'image-source') {
      selectedFilters.type = filterValue;
    } else if (filterCategory === 'art-styles') {
      selectedFilters.style = filterValue;
    } else if (filterCategory === 'advanced') {
      selectedFilters.sort = filterValue;
    }

    // Highlight the selected menu item
    document.querySelectorAll(`.filter-button[data-category="${filterCategory}"]`).forEach((btn) => {
      btn.classList.remove('selected');
    });
    event.target.classList.add('selected');

    // Call applyFilters() to update the images
    applyFilters();
  });
});











        
          document.getElementById("enhance-prompt-button").addEventListener("click", async () => {
              const promptInput = document.getElementById("prompt-input");
              const prompt = promptInput.value.trim();

              // Check if the prompt is empty
              if (!prompt) {
                showToast("Please enter a prompt!", "error");
                return;
              }

              try {
                // Send the prompt to the server
                const response = await fetch("/enhance-prompt", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ prompt })
                });

                if (!response.ok) {
                  throw new Error("Failed to enhance the prompt. Please try again.");
                }

                const data = await response.json();
                promptInput.value = data.result; // Update the input area with the enhanced prompt
                showToast("Prompt enhanced successfully!", "success");
              } catch (error) {
                console.error(error);
                showToast(error.message, "error");
              }
            });
        
        
          document.getElementById('create-button').addEventListener('click', async () => {
          try {
            // Check authentication status
            const response = await fetch('/check-auth', { method: 'GET' });
            const data = await response.json();

            if (!data.isAuthenticated) {
              // Show a toast notification if the user is not logged in
              showToast('Please log in first to create an image.', 'error');
              return; // Prevent further actions
            }

            // Proceed with copying the prompt if the user is authenticated
            const promptText = document.getElementById('modal-prompt').textContent.trim();
            const mainPromptInput = document.getElementById('prompt-input');

            if (mainPromptInput && promptText) {
              mainPromptInput.value = promptText; // Copy the prompt text to the main input
              document.getElementById('comments-modal').classList.add('hidden'); // Close the modal
              showToast('Prompt copied! Ready to create similar.', 'success'); // Optional: Provide feedback
            }
          } catch (error) {
            console.error('Error checking authentication:', error);
            showToast('An error occurred. Please try again.', 'error');
          }
        });


        
          document.getElementById('copy-prompt').addEventListener('click', () => {
              const promptText = document.getElementById('modal-prompt').textContent.trim();

              // Check if there's text to copy
              if (promptText) {
                navigator.clipboard.writeText(promptText).then(() => {
                  // Show success toast
                  showToast('Prompt copied to clipboard!');
                }).catch(err => {
                  // Show error toast if copying fails
                  showToast('Failed to copy prompt', 'error');
                  console.error('Copy failed:', err);
                });
              } else {
                showToast('No prompt to copy', 'error');
              }
            });



           

modalImage.addEventListener('click', (event) => {
  event.stopPropagation(); // Prevent the click from propagating to parent elements
  openFullscreenModal(modalImage.src); // Open the fullscreen modal with the current image URL
});
        
        

// Function to adjust dimensions to be multiples of 64 and within the specified range
function adjustDimensions(dimensions, model) {
  const minSize = 256;
  const multiple = 64;

  // Determine the max size based on the selected model
  const isFluxModel = model.toLowerCase().includes('flux'); // Check if the model is a FLUX model
  const maxSize = isFluxModel ? 1280 : 1536; // Set max size to 1280 for FLUX models, 1536 for others

  // Ensure width is a multiple of 64 and within the range
  dimensions.width = Math.max(minSize, Math.min(maxSize, dimensions.width));
  dimensions.width = Math.round(dimensions.width / multiple) * multiple;

  // Ensure height is a multiple of 64 and within the range
  dimensions.height = Math.max(minSize, Math.min(maxSize, dimensions.height));
  dimensions.height = Math.round(dimensions.height / multiple) * multiple;

  return dimensions;
}
  

document.getElementById('generate-button').addEventListener('click', async () => {
  // Ensure the user is logged in
  if (!window.isLoggedIn) {
    showToast('Please log in to generate images.', 'error');
    console.error('User is not logged in');
    return;
  }

  // Check if the user has enough tokens
  const tokenCountElement = document.getElementById('token-count');
  const currentTokens = parseFloat(tokenCountElement.textContent.replace(' Tokens', ''));

  if (currentTokens <= 0) {
    showToast('You do not have enough tokens to generate an image.', 'error');
    console.error('Not enough tokens');
    return;
  }

  // Get the prompt and options
  const prompt = document.getElementById('prompt-input').value.trim();
  const options = JSON.parse(localStorage.getItem('options')) || {};

  const modelSelect = document.getElementById('model-select');
  const model = modelSelect ? modelSelect.value : '';    
    
  // Use selectedImageState.dimensions or fallback to options/defaults
  const dimensions = selectedImageState.dimensions || {
      width: parseInt(options.width) || 800,
      height: parseInt(options.height) || 600,
  };

  // Ensure width and height are integers
  dimensions.width = Math.round(dimensions.width);
  dimensions.height = Math.round(dimensions.height);
               
  // Adjust dimensions to be multiples of 64 and within the range
  const adjustedDimensions = adjustDimensions(dimensions, model);

  const guidanceScale = parseFloat(options.guidanceScale) || 10;
  const inferenceSteps = parseInt(options.inferenceSteps) || 25;
  const strength = parseFloat(document.getElementById('image-strength-modal').value) || 0.75;

  const styleSelect = document.getElementById('style-select');  
  const style = styleSelect ? styleSelect.value : '';
  

  const selectedThumbnailContainer = document.getElementById('selected-thumbnail-container');
  const selectedImage = selectedThumbnailContainer && selectedThumbnailContainer.dataset.imagePath;

  if (!prompt) {
    showToast('Please enter a prompt.', 'error');
    console.error('No prompt entered.');
    return;
  }

  if (!model) {
    showToast('Please select a model before generating an image.', 'error');
    console.error('No model selected.');
    return;
  }

  if (activeTab !== 'profile') {
    // Perform the actual tab switching
    await switchTab('profile'); // Switch to profile view if not already done
    await delay(500);
  }

  // Add Placeholder
  const imageList = document.getElementById('image-list');
  if (!imageList) {
    console.error('Image List container not found in the DOM.');
    showToast('An error occurred. Please try again.', 'error');
    return;
  }

  // Placeholder Div
  const imageContainer = document.createElement('div');
  imageContainer.classList.add('image-card', 'relative', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');
  imageContainer.style.backgroundColor = '#2d2d2d';

  const gridSizer = document.querySelector('.grid-sizer');
  const masonryColumnWidth = gridSizer ? gridSizer.offsetWidth : 300;
  const thumbnailHeight = (dimensions.height / dimensions.width) * masonryColumnWidth; // Preserve aspect ratio

  imageContainer.style.width = `${masonryColumnWidth}px`;
  imageContainer.style.height = `${thumbnailHeight}px`;

  imageContainer.innerHTML = `<div class="flex justify-center items-center h-full">
      <div class="spinner"></div>
    </div>`;

  // Add placeholder to Masonry and re-layout
  imageList.prepend(imageContainer); // Add placeholder at the top
  msnry.prepended(imageContainer); // Let Masonry know about the new element
  msnry.layout(); // Recalculate Masonry layout

  // Scroll to the top of the page
  window.scrollTo({
    top: 0,
    behavior: 'smooth',
  });

  try {
    // Show loading state
    const generateButton = document.getElementById('generate-button');
    generateButton.textContent = 'Processing...';
    generateButton.disabled = true;

    const { keepFace, keepStyle, keepPose } = selectedImageState;

    const url = selectedImage ? '/edit-image' : '/generate-image';
    const payload = selectedImage
      ? {
          imagePath: selectedImage,
          prompt: prompt,
          strength: strength,
          steps: inferenceSteps,
          guidance: guidanceScale,
          style,
          model,
          keepStyle,
          keepFace,
          keepPose,          
          width: parseInt( dimensions.width , 10),
          height: parseInt( dimensions.height, 10),
          
        }
      : {
          prompt: prompt,
          isPublic: options.isPublic || false,
          width: dimensions.width,
          height: dimensions.height,
          guidanceScale,
          inferenceSteps,
          style,
          model,
        };

    // Debug: Log the payload
    console.log('Payload:', payload);

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    const data = await response.json();
    if (response.ok && data.imageUrl) {
      const imgElement = document.createElement('img');
      imgElement.src = data.imageUrl;
      imgElement.alt = selectedImage ? 'Edited Image' : 'Generated Image';
      imgElement.classList.add('w-full', 'h-auto', 'object-cover', 'rounded-lg');
      imgElement.style.display = 'none';
      imageContainer.appendChild(imgElement);

      imgElement.addEventListener('load', () => {
        imgElement.style.display = 'block';
        const spinner = imageContainer.querySelector('.spinner');
        if (spinner) spinner.remove();
        updateTokenCount(-data.tokensUsed);

        setTimeout(() => {
          document.getElementById('profile-toggle').click();
        }, 500);

        showToast('Image processed successfully!', 'success');
      });

      imgElement.addEventListener('error', () => {
        showToast('Failed to load image.', 'error');
        imageList.removeChild(imageContainer);
        msnry.remove(imageContainer); // Remove from Masonry
        msnry.layout();
      });
    } else {
      showToast(data.error || 'Failed to process image.', 'error');
      imageList.removeChild(imageContainer);
      msnry.remove(imageContainer); // Remove from Masonry
      msnry.layout();
    }
  } catch (error) {
    console.error('Error processing image:', error);
    showToast('An error occurred while processing the image.', 'error');
    imageList.removeChild(imageContainer);
    msnry.remove(imageContainer); // Remove from Masonry
    msnry.layout();
  } finally {
    const generateButton = document.getElementById('generate-button');
    generateButton.textContent = selectedImage ? 'Modify' : 'Generate';
    generateButton.disabled = false;
  }
});


// Update the strength value display when the slider changes
document.getElementById('image-strength-modal').addEventListener('input', (event) => {
  document.getElementById('image-strength-value').textContent = event.target.value;
});






        
        
        
      // Handle Google Authentication Button Click
      const googleAuthButton = document.getElementById('google-auth-button');
      if (googleAuthButton) {
        googleAuthButton.addEventListener('click', () => {
          // Redirect to Google OAuth endpoint
          window.location.href = '/auth/google';
        });
      }

      // Modal Elements
      const modals = {
        'options-modal': document.getElementById('options-modal'),
        'setup-character-modal': document.getElementById('setup-character-modal'),
        'buy-tokens-modal': document.getElementById('buy-tokens-modal'),
      };

   // Function to open a modal
function openModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.remove('hidden');
    document.body.classList.add('modal-open');    
    document.body.classList.add('overflow-hidden'); // Prevent background scrolling
  }
}




       document.getElementById('options-button').addEventListener('click', () => {
      const optionsModal = document.getElementById('options-modal');
      if (optionsModal.classList.contains('hidden')) {
        openModal('options-modal');
      } else {
        closeModal('options-modal');
      }
    });



      document.getElementById('tokens-button').addEventListener('click', async () => {
          try {
            // Fetch user data to check if the user is logged in
            const response = await fetch('/user-data');
            const userData = await response.json();

            if (!userData.loggedIn) {
              // If user is not logged in, show a message instead of the token modal
              showToast('Please log in to buy tokens.', 'error');
              return;
            }

            // Show the Buy Tokens Modal if the user is logged in
            document.getElementById('buy-tokens-modal').classList.remove('hidden');
          } catch (error) {
            console.error('Error checking user login status:', error);
            showToast('An error occurred. Please try again.', 'error');
          }
        });

        document.getElementById('buy-tokens-modal').addEventListener('click', (e) => {
  if (e.target === document.getElementById('buy-tokens-modal')) {
    document.getElementById('buy-tokens-modal').classList.add('hidden');
  }
});

      document.getElementById('buy-tokens-form').addEventListener('submit', async (e) => {
  e.preventDefault();

  const bundle = document.getElementById('token-bundle');
  const tokens = bundle.value;
  const price = bundle.options[bundle.selectedIndex].dataset.price;

  const validBundles = {
    "300": "3.00",
    "500": "5.00",
    "1200": "10.00",
    "3000": "20.00",
    "5000": "30.00",
    "20000": "100.00",
  };

  if (!validBundles[tokens] || validBundles[tokens] !== price) {
    alert("Invalid token bundle selected. Please try again.");
    return;
  }

  try {
    const response = await fetch('/create-checkout-session', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tokens, price }),
    });

    const session = await response.json();
    if (response.ok) {
      const stripe = Stripe('pk_live_51QNNomGgZQx5JKvIyEzYuHbqZRdugWTVlseapCphcAL3gYdrXfSIN8R6toeaReScar1gFyxRODHv0XG1cf54xUsM00zJcyWw8j');
      await stripe.redirectToCheckout({ sessionId: session.id });
    } else {
      alert('Failed to initiate payment');
    }
  } catch (error) {
    console.error('Error:', error);
    alert('An error occurred while processing your payment');
  }
});



        
        
        
      // Event Listeners for Closing Modals
      document.querySelectorAll('[id^="close-"]').forEach(button => {
        button.addEventListener('click', () => {
          const modalId = button.id.replace('close-', '');
          closeModal(modalId);
        });
      });

      // Close any open modals when clicking outside the modal content
      Object.keys(modals).forEach(modalId => {
        const modal = modals[modalId];
        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              closeModal(modalId);
            }
          });
        }
      });

     


      // Handle Setup Character Form Submission
      document.getElementById('setup-character-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const name = document.getElementById('character-name').value.trim();
        const description = document.getElementById('character-description').value.trim();
        const faceUpload = document.getElementById('face-upload-character').files[0];

        if (name && description) {
          // Save to LocalStorage
          let characters = JSON.parse(localStorage.getItem('characters')) || [];
          characters.push({ name, description, faceUpload: faceUpload ? faceUpload.name : null });
          localStorage.setItem('characters', JSON.stringify(characters));

          // Update Character Dropdown
          populateCharacterDropdown();

          // Clear the form
          document.getElementById('setup-character-form').reset();

          // Close Modal
          closeModal('setup-character-modal');

          showToast('Character added successfully!', 'success');
        } else {
          showToast('Please fill in all fields.', 'error');
        }
      });

    

      // Function to update the token count in the navbar
      function updateTokenCount(amount) {
        const tokenCountElement = document.getElementById('token-count');
        if (tokenCountElement) {
          let currentTokens = parseInt(tokenCountElement.textContent.replace('Tokens: ', '')) || 0;
          currentTokens += amount;
          tokenCountElement.textContent = `Tokens: ${currentTokens}`;

          // Optionally, update backend if needed
          // Example: send updated token count to backend
        }
      }
        
        
      document.addEventListener('click', (event) => {
  if (event.target.id === 'public-toggle') {
    switchTab('public');
  } else if (event.target.id === 'profile-toggle') {
      
    if (!window.isLoggedIn) {
       showToast('Please log in to view your profile.', 'error');       
    }else{
       switchTab('profile');
    }
  } else if (event.target.id === 'search-results-toggle') {
    switchTab('search');
  }
});


        
        /*
        
        window.addEventListener('scroll', () => {
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const scrollHeight = document.documentElement.scrollHeight;
  const clientHeight = window.innerHeight || document.documentElement.clientHeight;

  // Check if we're near the bottom
  if (scrollTop + clientHeight >= scrollHeight - 50) {
    if (hasMoreImages && !isLoading) {
      const apiEndpoint = `/api/public-posts?type=ai-generated&page=${page}&`;
      loadImages(apiEndpoint, 'public'); // No need to pass isInitialLoad here
    }
  }
});*/
        
   
window.addEventListener('scroll', () => {
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  const scrollHeight = document.documentElement.scrollHeight;
  const clientHeight = window.innerHeight || document.documentElement.clientHeight;

  // If near the bottom
  if (scrollTop + clientHeight >= scrollHeight - 50) {
    // Check if the current tab is public, profile, or search
    if (activeTab === 'profile') {
      // Load more profile images if we have more
      if (hasMoreImages && !isLoadingImages) {
        const userId = window.location.pathname.split('/')[2]; // Extract user ID from URL
        const apiEndpoint = `/api/user-profile/${userId}?page=${page}`;
        loadImages(apiEndpoint, 'profile');
      }
    } else if (activeTab === 'search') {
      // Search results
      if (hasMoreImages && !isLoadingImages) {
        const query = document.getElementById('search-query').value.trim();
        const apiEndpoint = `/api/search?query=${query}&type=${activeFilters['image-source'] || 'ai-generated'}&style=${activeFilters['art-styles'] || 'all-styles'}&sort=${activeFilters['advanced'] || 'newest'}&page=${page}&limit=10`;
        loadImages(apiEndpoint, 'search');
      }
    } else {
      // Otherwise assume public is active
      if (hasMoreImages && !isLoadingImages) {
        const apiEndpoint = `/api/public-posts?type=${activeFilters['image-source'] || 'ai-generated'}&style=${activeFilters['art-styles'] || 'all-styles'}&sort=${activeFilters['advanced'] || 'newest'}&page=${page}&limit=10`;
        loadImages(apiEndpoint, 'public');
      }
    }
  }
});


        
        
/*

      // Handle Public Posts Toggle Button
document.getElementById('public-toggle').addEventListener('click', () => {
  // Hide or clear the user profile elements
  const profileUsername = document.getElementById('profile-username');
  const profileAvatar = document.getElementById('profile-avatar');
  if (profileUsername) profileUsername.textContent = ''; // Clear username
  if (profileAvatar) {
    profileAvatar.src = ''; // Clear avatar
    profileAvatar.classList.add('hidden'); // Hide avatar
  }

  // Reset pagination state when switching to Public Posts
  page = 1; // Reset the page number
  hasMoreImages = true; // Ensure hasMoreImages is set to true

  // Toggle button styles
  document.getElementById('public-toggle').classList.add('selected-toggle');
  document.getElementById('profile-toggle').classList.remove('selected-toggle');
  document.getElementById('search-results-toggle').classList.remove('selected-toggle'); // Deactivate Search Results toggle
  document.getElementById('search-results-toggle').classList.add('hidden'); // Hide Search Results toggle

  // Reset filters to default for Public Posts
  activeFilters['image-source'] = 'ai-generated';
  activeFilters['art-styles'] = 'all-styles';
  activeFilters['advanced'] = 'newest';
  console.log("Reset Filters:", activeFilters);

  // Apply filters for Public Posts
  applyFilters();
});

// Handle Profile Posts Toggle Button
document.getElementById('profile-toggle').addEventListener('click', async () => {
  // Hide or clear the user profile elements
  const profileUsername = document.getElementById('profile-username');
  const profileAvatar = document.getElementById('profile-avatar');
  if (profileUsername) profileUsername.textContent = ''; // Clear username
  if (profileAvatar) {
    profileAvatar.src = ''; // Clear avatar
    profileAvatar.classList.add('hidden'); // Hide avatar
  }

  // Fetch user data to check authentication
  let userData;
  try {
    const response = await fetch('/user-data');
    userData = await response.json();
  } catch (error) {
    console.error('Error fetching user data:', error);
    showToast('An error occurred. Please try again.', 'error');
    return;
  }

  if (!userData.loggedIn) {
    // Display a message prompting the user to log in
    showToast('Please log in to view your posts.', 'error');
    return;
  }

  // Toggle button styles
  document.getElementById('profile-toggle').classList.add('selected-toggle');
  document.getElementById('public-toggle').classList.remove('selected-toggle');
  document.getElementById('search-results-toggle').classList.remove('selected-toggle'); // Deactivate Search Results toggle
  document.getElementById('search-results-toggle').classList.add('hidden'); // Hide Search Results toggle

  // Load private/profile posts
  loadPrivatePosts();
});

// Handle Search Results Toggle Button Visibility
document.getElementById('search-results-toggle').addEventListener('click', () => {
  // Toggle button styles
  document.getElementById('search-results-toggle').classList.add('selected-toggle');
  document.getElementById('public-toggle').classList.remove('selected-toggle');
  document.getElementById('profile-toggle').classList.remove('selected-toggle');

  // No need to reload results, as the search results are already displayed
});

*/

      // Handle Buy Tokens Selection
      document.querySelectorAll('.select-token-button').forEach(button => {
        button.addEventListener('click', async () => {
          const tokens = parseInt(button.getAttribute('data-tokens'));
          const price = parseFloat(button.getAttribute('data-price'));

          try {
            if (tokens === 0) {
              showToast('The Free package offers 0 tokens.', 'error');
              return;
            }

            // Initiate payment process via backend
            const response = await fetch('/buy-tokens', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tokens, price }),
            });

            const data = await response.json();

            if (response.ok) {
              showToast(`Successfully purchased ${tokens} tokens!`, 'success');
              // Update token count in navbar
              updateTokenCount(tokens);
              // Close the Buy Tokens Modal
              closeModal('buy-tokens-modal');
            } else {
              showToast(data.error || 'Failed to purchase tokens.', 'error');
            }
          } catch (error) {
            console.error('Error purchasing tokens:', error);
            showToast('An error occurred while purchasing tokens.', 'error');
          }
        });
      });

     
 



      // Accessibility: Close any open modals when focusing on the prompt input
      const promptInput = document.getElementById('prompt-input');
      if (promptInput) {
        promptInput.addEventListener('focus', () => {
          for (let modalId in modals) {
            if (!modals[modalId].classList.contains('hidden')) {
              closeModal(modalId);
            }
          }
        });
      }
    }

    // Function to populate the character dropdown
    function populateCharacterDropdown() {
      const characterSelect = document.getElementById('character-select');
      if (!characterSelect) return;

      characterSelect.innerHTML = '<option value="" disabled selected>Select Character</option>'; // Reset options

      const characters = JSON.parse(localStorage.getItem('characters')) || [];
      characters.forEach((char, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = char.name;
        characterSelect.appendChild(option);
      });
    }

  
   function showFullSizeImage(imageUrl) {
      // Create a modal element
      const modal = document.createElement('div');
      modal.classList.add('fixed', 'inset-0', 'bg-black', 'bg-opacity-75', 'flex', 'justify-center', 'items-center', 'z-50');
      modal.innerHTML = `
        <div class="relative">
          <img src="${imageUrl}" alt="Full Image" class="max-w-full max-h-screen rounded-lg">
          <button class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full" id="close-modal">&times;</button>
        </div>
      `;

      // Append modal to the document body
      document.body.appendChild(modal);

      // Add event listener to close the modal when clicking the close button or outside the image
      modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target.id === 'close-modal') {
          modal.remove();
        }
      });
       
} //End events 

      


async function loadComments(imageId) {
  try {
    const response = await fetch(`/images/${imageId}/comments`);
    if (!response.ok) {
      throw new Error('Failed to fetch comments.');
    }

    const comments = await response.json();

    const commentsList = document.getElementById('comments-list');
    commentsList.innerHTML = ''; // Clear old comments

    comments.forEach(comment => {
      const li = document.createElement('li');
      li.classList.add('flex', 'items-start', 'space-x-2'); // For layout

      // Create a link to the user's profile
      const userProfileLink = document.createElement('a');
      userProfileLink.href = `/user-profile/${comment.userId}`; // Link to the user's profile
      userProfileLink.classList.add('flex', 'items-start', 'space-x-2', 'hover:underline'); // Add hover effect

      // Add the user's avatar
      const avatar = document.createElement('img');
      avatar.src = comment.avatar || '/default-avatar.png'; // Fallback to default avatar
      avatar.alt = comment.username;
      avatar.classList.add('w-8', 'h-8', 'rounded-full');
      avatar.crossOrigin = 'anonymous';
      avatar.referrerPolicy = 'no-referrer';

      // Add the user's username and comment content
      const commentContent = document.createElement('div');
      commentContent.innerHTML = `
        <p class="font-bold text-black">${comment.username}</p>
        <p class="text-gray-600">${comment.content}</p>
      `;

      // Append the avatar and comment content to the profile link
      userProfileLink.appendChild(avatar);
      userProfileLink.appendChild(commentContent);

      // Append the profile link to the list item
      li.appendChild(userProfileLink);

      // Append the list item to the comments list
      commentsList.appendChild(li);
    });
  } catch (error) {
    console.error('Error loading comments:', error);
  }
}

  
      
      
      
    //////////////////////////////////  
      
   

    /*********************************************/
/* Function to load images from your API      */
/*********************************************/
async function loadImages(apiEndpoint, mode, isInitialLoad = false) {
  if (isLoading || !hasMoreImages) return;
  isLoading = true;

  try {
    const response = await fetch(apiEndpoint);
    if (!response.ok) throw new Error('Failed to load images.');

    const data = await response.json();
    const images = data.images;

    if (!Array.isArray(images)) {
      throw new Error('Invalid data format: "images" is not an array.');
    }

    const imageList = document.getElementById('image-list');
    if (!imageList) return;

    // Clear the image list only on the first page load
    if (page === 1) {
      imageList.innerHTML = '<div class="grid-sizer"></div>';
    }

    if (images.length === 0 && page === 1) {
      imageList.innerHTML = '<p class="text-white text-center mt-4">No images found. Try a different search query.</p>';
      hasMoreImages = false;
      return;
    }

    // Keep track of new items so we can pass them to Masonry
    const newItems = [];

    images.forEach((image) => {
      if (!image.imageUrl) return;

      // Create the Masonry "tile"
      const imageCard = document.createElement('div');
      imageCard.classList.add('image-card');

      // Like button
      const likeButton = document.createElement('button');
      likeButton.classList.add('like-button');
      const heartIcon = document.createElement('i');
      heartIcon.classList.add('fas', 'fa-heart');
      if (image.likedByUser) {
        heartIcon.classList.add('liked');
      }
      likeButton.appendChild(heartIcon);
      likeButton.dataset.isPublic = image.isPublic;
      likeButton.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleLike(image.id, likeButton);
      });

      // The card's inner HTML
      imageCard.innerHTML = `
        <div class="relative">
          <img src="${image.imageUrl}" alt="${image.title || 'Image'}" class="w-full rounded-lg" />
        </div>
      `;

      // Insert the Like button
      imageCard.querySelector('.relative').appendChild(likeButton);

      // Add click event for opening comments
      imageCard.querySelector('img').addEventListener('click', () => {
        openCommentsModal(image.id, image.imageUrl, mode);
      });

      // Append to the DOM
      imageList.appendChild(imageCard);
      newItems.push(imageCard);
    });

    // After adding all new items, wait until they're fully loaded, then Masonry them
    imagesLoaded(newItems, () => {
      msnry.appended(newItems); // Tell Masonry about new elements
      msnry.layout();          // Recalculate layout

      // Check if we need to load more pages to fill the viewport
      if (isInitialLoad && hasMoreImages) {
        const viewportHeight = window.innerHeight;
        const contentHeight = imageList.getBoundingClientRect().height;

        if (contentHeight < viewportHeight) {
          // Load the next page to fill the viewport
          const nextEndpoint = `/api/public-posts?type=ai-generated&page=${page + 1}&`;
          loadImages(nextEndpoint, mode, true); // Recursively call with isInitialLoad = true
        }
      }
    });

    hasMoreImages = data.hasMore;
    if (hasMoreImages) {
      page++;
    }
  } catch (error) {
    console.error(`Error loading images from ${apiEndpoint}:`, error);
    showToast('An error occurred while loading images.', 'error');
  } finally {
    isLoading = false;
  }
}

      
function removeThumbnail() {
  const thumbnailContainer = document.getElementById('selected-thumbnail-container');
  const promptStatusText = document.getElementById('prompt-status-text'); // Get the status text element

  if (thumbnailContainer) {
    thumbnailContainer.innerHTML = ''; // Clear the thumbnail
    delete thumbnailContainer.dataset.imagePath; // Remove the image path
    
    // Reset the button text to "Generate"
    const generateText = document.querySelector('#generate-button .generate-text');
    if (generateText) {
      generateText.textContent = 'Generate';
    }

    // Reset the status text and color
    if (promptStatusText) {
      promptStatusText.textContent = 'Generate an image';
      promptStatusText.classList.remove('red');
    }
  }
}

  async function loadPrivatePosts() {
      if (isLoading || !hasMoreImages) return;
      isLoading = true;

      try {
        const response = await fetch(`/personal-images?page=${page}`);
        if (!response.ok) {
          throw new Error('Failed to load profile posts');
        }

        const data = await response.json();
        const images = data.images;
        const imageList = document.getElementById('image-list');
        if (!imageList) {
          console.error('Image List container not found in the DOM.');
          return;
        }

        // For the first page, clear the container and re-add the grid-sizer
        if (page === 1) {
          imageList.innerHTML = '<div class="grid-sizer"></div>'; // Ensures Masonry's grid-sizer remains
        }

        // If no images on the first page, display a message
        if (images.length === 0 && page === 1) {
          imageList.innerHTML = '<p class="text-white text-center mt-4"></p>';
          hasMoreImages = false;
          return;
        }

        // Track newly created items to add to Masonry
        const newItems = [];

        // Loop through images and create image cards
        images.forEach((image) => {
          const imageCard = document.createElement('div');
          imageCard.classList.add('image-card', 'relative', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');
          imageCard.dataset.imageId = image.id;

          // Add Public/Private Badge
          const badge = document.createElement('span');
          badge.classList.add(
            'badge',
            image.isPublic ? 'badge-public' : 'badge-private',
            'absolute',
            'top-2',
            'left-2',
            'px-2',
            'py-1',
            'rounded',
            'text-sm',
            'font-bold',
            'text-white',
            image.isPublic ? 'bg-green-500' : 'bg-red-500'
          );
          badge.textContent = image.isPublic ? 'Public' : 'Private';

          // Build card content
imageCard.innerHTML = `
  <div class="relative">
    <img src="${image.thumbnailUrl}" alt="${image.isPublic ? 'Public' : 'Private'} Image" 
         class="w-full h-auto rounded-lg cursor-pointer" loading="lazy" />
    
    <!-- Bottom Buttons (Keep Style, Face, Pose) -->
    <div class="toggle-buttons absolute bottom-2 left-2 right-2 flex hidden gap-2">
      <button id="toggle-style-${image.id}" class="bg-gray-700 hover:bg-green-600 text-white px-1.5 py-0.5 rounded text-sm w-full" title="Keep Style">
        <i class="fas fa-palette"></i>→
      </button>
      <button id="toggle-face-${image.id}" class="bg-gray-700 hover:bg-green-600 text-white px-1.5 py-0.5 rounded text-sm w-full" title="Keep Face">
        <i class="fas fa-user text-gray-200"></i>→
      </button>
      <button id="toggle-pose-${image.id}" class="bg-gray-700 hover:bg-green-600 text-white px-1.5 py-0.5 rounded text-sm w-full" title="Keep Pose">
        <i class="fas fa-running"></i>→
      </button>
    </div>
    
    <!-- Top-Right Action Buttons (Info and Visibility Toggle) -->
    <div class="action-buttons hidden absolute top-2 right-2 flex flex-col gap-2">
      <button class="info-button bg-blue-600 text-white p-1 rounded shadow hover:bg-blue-500" title="Comments">
        <i class="fas fa-info-circle"></i>
      </button>
      <button class="toggle-visibility-button bg-blue-600 text-white p-1 rounded shadow hover:bg-blue-500" data-id="${image.id}" title="${image.isPublic ? 'Make Private' : 'Make Public'}">
        <i class="${image.isPublic ? 'fas fa-lock' : 'fas fa-globe'}"></i>
      </button>
    </div>
  </div>
`;
          // Append the badge to the card
          imageCard.appendChild(badge);

          // Add the image card to the DOM
          imageList.appendChild(imageCard);
          newItems.push(imageCard); // Add to newItems array for Masonry

          // Add event listeners for buttons and actions
          const styleButton = imageCard.querySelector(`#toggle-style-${image.id}`);
          const faceButton = imageCard.querySelector(`#toggle-face-${image.id}`);
          const poseButton = imageCard.querySelector(`#toggle-pose-${image.id}`);
          const imgElement = imageCard.querySelector('img');
          const actionButtons = imageCard.querySelector('.action-buttons');

          const infoButton = imageCard.querySelector('.info-button');
          infoButton.addEventListener('click', (event) => {
            event.stopPropagation();
            openCommentsModal(image.id, image.imageUrl, 'private'); // Pass 'private' or any relevant mode
          });

          // Function to deactivate other toggle buttons
          const deactivateOtherButtons = (activeButton) => {
            if (activeButton !== styleButton) {
              styleButton.classList.remove('active');
              selectedImageState.keepStyle = false;
            }
            if (activeButton !== faceButton) {
              faceButton.classList.remove('active');
              selectedImageState.keepFace = false;
            }
            if (activeButton !== poseButton) {
              poseButton.classList.remove('active');
              selectedImageState.keepPose = false;
            }
          };

      // Event listener for Keep Style button
        styleButton.addEventListener('click', (event) => {
          event.stopPropagation();
          styleButton.classList.toggle('active');
          selectedImageState.keepStyle = styleButton.classList.contains('active');
          console.log('Keep Style Toggled:', selectedImageState.keepStyle); // Debug log
        });

        // Event listener for Keep Face button
        faceButton.addEventListener('click', (event) => {
          event.stopPropagation();
          faceButton.classList.toggle('active');
          selectedImageState.keepFace = faceButton.classList.contains('active');
          console.log('Keep Face Toggled:', selectedImageState.keepFace); // Debug log
        });

        // Event listener for Keep Pose button
        poseButton.addEventListener('click', (event) => {
          event.stopPropagation();
          poseButton.classList.toggle('active');
          selectedImageState.keepPose = poseButton.classList.contains('active');
          console.log('Keep Pose Toggled:', selectedImageState.keepPose); // Debug log
        });

      // Add a double-click event to open the comments modal
      imgElement.addEventListener('dblclick', (event) => {
        event.stopPropagation();
        openCommentsModal(image.id, image.imageUrl, 'private'); // Pass 'private' or any relevant mode
      });

      imgElement.addEventListener('click', (event) => {
          event.stopPropagation();
          const toggleButtons = imageCard.querySelector('.toggle-buttons');
          const generateButton = document.getElementById('generate-button');

          if (selectedImages.has(image.id)) {
            selectedImages.delete(image.id);
            imageCard.style.border = 'none';
            imageCard.style.backgroundColor = 'transparent';
            actionButtons.classList.add('hidden');
            if (toggleButtons) toggleButtons.classList.add('hidden');

            if (selectedImages.size === 0) {
              // No image is selected, default to Flux models
              populateModelDropdownForImageSelection("", false);
              resetStylesToAllStyles();
              removeThumbnail();
              selectedImageState.dimensions = null;
            }
          } else {
            const allCards = document.querySelectorAll('.image-card');
            allCards.forEach((card) => {
              card.style.border = 'none';
              card.style.backgroundColor = 'transparent';
              card.querySelector('.action-buttons')?.classList.add('hidden');
              card.querySelector('.toggle-buttons')?.classList.add('hidden');
            });

            selectedImages.clear();
            selectedImages.add(image.id);
            imageCard.style.border = '2px solid red';
            imageCard.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';

            actionButtons.classList.remove('hidden');
            if (toggleButtons) toggleButtons.classList.remove('hidden');
            showCreateImage();
            updatePromptBox(image);

            // Calculate aspect ratio from the thumbnail
            const thumbnailImg = new Image();
            thumbnailImg.src = image.thumbnailUrl;

            thumbnailImg.onload = () => {
              const thumbnailAspectRatio = thumbnailImg.width / thumbnailImg.height;
              const defaultWidth = 800;
              const calculatedHeight = defaultWidth / thumbnailAspectRatio;

              selectedImageState.dimensions = {
                width: defaultWidth,
                height: calculatedHeight,
              };

              console.log('selectedImageState.dimensions.width:', selectedImageState.dimensions.width);
              console.log('selectedImageState.dimensions.height:', selectedImageState.dimensions.height);
            };

            thumbnailImg.onerror = () => {
              console.error('Failed to load thumbnail for aspect ratio calculation.');
              selectedImageState.dimensions = {
                width: 800,
                height: 600,
              };
            };

            // Update the selected image state with the current toggle button states
            selectedImageState = {
              imageId: image.id,
              keepFace: faceButton.classList.contains('active'),
              keepStyle: styleButton.classList.contains('active'),
              keepPose: poseButton.classList.contains('active'),
            };

            console.log('Updated selectedImageState:', selectedImageState);

            // Update the model dropdown based on the selected style
            const styleSelect = document.getElementById('style-select');
            if (styleSelect) {
                
              // Force the model dropdown to switch to a compatible model for image-to-image

              if (styleSelect) {
                const selectedStyle = styleSelect.value;
                populateModelDropdownForImageSelection(selectedStyle, true); // Image is selected
                              
                styleSelect.addEventListener('change', (event) => {
                    const selectedStyle = event.target.value;
                    const isImageSelected = selectedImages.size > 0;
                    populateModelDropdownForImageSelection(selectedStyle, isImageSelected);
                });
                  
                
              }
            }
          }
      });
            
            
            
      /*
      const deleteButton = imageCard.querySelector('.delete-button');
      deleteButton.addEventListener('click', async (event) => {
        event.stopPropagation();
        const imageId = event.target.closest('button').getAttribute('data-id');
        try {
          const response = await fetch('/delete-private-image/' + imageId, { method: 'DELETE' });
          if (response.ok) {
            showToast('Image deleted successfully!', 'success');
            // Notify Masonry about the element removal
              msnry.remove(imageCard);

              // Recalculate the layout to fill the gap
              msnry.layout();

              // Remove the card from the DOM
              imageCard.remove();

              // Clean up any references to the deleted image
              selectedImages.delete(imageId);
          } else {
            showToast('Failed to delete image', 'error');
          }
        } catch (error) {
          console.error('Error deleting image:', error);
          showToast('An error occurred while deleting the image', 'error');
        }
      });*/

      const toggleVisibilityButton = imageCard.querySelector('.toggle-visibility-button');
      toggleVisibilityButton.addEventListener('click', async (event) => {
          event.stopPropagation();
          const imageId = event.target.closest('button').getAttribute('data-id');
          try {
            const response = await fetch(`/update-image-visibility/${imageId}`, { 
              method: 'PUT', 
              headers: { 'Content-Type': 'application/json' } 
            });
            if (response.ok) {
              const data = await response.json();
              showToast('Image visibility updated!', 'success');

              // Update the button and marker without refreshing the entire list
              const badge = imageCard.querySelector('.badge');
              const toggleButton = imageCard.querySelector('.toggle-visibility-button i');

              if (badge && toggleButton) {
                // Toggle the badge text and classes
                if (data.isPublic) {
                  badge.textContent = 'Public';
                  badge.classList.remove('badge-private', 'bg-red-500');
                  badge.classList.add('badge-public', 'bg-green-500');
                } else {
                  badge.textContent = 'Private';
                  badge.classList.remove('badge-public', 'bg-green-500');
                  badge.classList.add('badge-private', 'bg-red-500');
                }

                // Toggle the button icon and title
                if (data.isPublic) {
                  toggleButton.classList.remove('fa-globe');
                  toggleButton.classList.add('fa-lock');
                  toggleButton.parentElement.setAttribute('title', 'Make Private');
                } else {
                  toggleButton.classList.remove('fa-lock');
                  toggleButton.classList.add('fa-globe');
                  toggleButton.parentElement.setAttribute('title', 'Make Public');
                }
              }
            } else {
              showToast('Failed to update visibility', 'error');
            }
          } catch (error) {
            console.error('Error updating image visibility:', error);
            showToast('An error occurred while updating visibility', 'error');
          }
        });  

            
    });

    // After adding all new items, wait for images to load, then integrate with Masonry
    imagesLoaded(newItems, () => {
      msnry.appended(newItems); // Tell Masonry about the new items
      msnry.layout();          // Recalculate Masonry layout
    });

    // Update the pagination state
    hasMoreImages = data.hasMore;
    if (hasMoreImages) {
      page++;
    }
  } catch (error) {
    console.error('Error loading private posts:', error);
    showToast('An error occurred while loading your posts.', 'error');
  } finally {
    isLoading = false;
  }
}
 
      
/**
 * Handles the state of the toggle buttons for style, face, and pose.
 * @param {string} toggleType - The type of toggle ("style", "face", "pose").
 * @param {string} imageId - The ID of the image being modified.
 * @param {boolean} isActive - Whether the toggle is active or not.
 */
function handleToggleState(toggleType, imageId, isActive) {
  console.log('Toggle changed: ${toggleType}, Image ID: ${imageId}, Active: ${isActive}');

  // Example: Update some global state or local storage
  if (!window.toggleStates) {
    window.toggleStates = {}; // Initialize if not already done
  }

  if (!window.toggleStates[imageId]) {
    window.toggleStates[imageId] = { style: false, face: false, pose: false };
  }

  // Update the state for the specific toggle type
  window.toggleStates[imageId][toggleType] = isActive;

  console.log('Updated Toggle States:', window.toggleStates);
 
  /*
  // Example: Disable style selection in the prompt box if "Keep Style" is active
  if (toggleType === 'style') {
    const styleSelect = document.getElementById('style-select');
    if (styleSelect) {
      styleSelect.disabled = isActive;
    }
  }*/
}
      
      
      

// Function to update the prompt box with a thumbnail
function updatePromptBox(image) {
  const promptInput = document.getElementById('prompt-input');
  const thumbnailContainer = document.getElementById('selected-thumbnail-container');
  const generateButton = document.getElementById('generate-button');
  const generateText = generateButton.querySelector('.generate-text'); // Get the text span
  const promptStatusText = document.getElementById('prompt-status-text'); // Get the status text element

  // Ensure the thumbnail container exists
  if (!thumbnailContainer) {
    console.error('Thumbnail container not found in the DOM.');
    return;
  }

  // Clear the thumbnail container to avoid duplicates
  thumbnailContainer.innerHTML = '';

  // Add the selected image thumbnail
  const thumbnail = document.createElement('img');
  thumbnail.src = image.thumbnailUrl;
  thumbnail.alt = 'Selected Image';
  thumbnail.classList.add('selected-thumbnail', 'rounded-lg', 'object-cover', 'ml-4', 'thumbnail-image');

  thumbnailContainer.appendChild(thumbnail);

  // Set the image path in the dataset
  thumbnailContainer.dataset.imagePath = image.imageUrl;

  // Change the button text to "Modify Image"
  if (generateText) {
    generateText.textContent = 'Modify'; // Update the text span
  }

  // Update the status text and color
  if (promptStatusText) {
    promptStatusText.textContent = 'Modify an Image'; // Updated text
    promptStatusText.classList.add('red');
  }
}




function hideCreateImagePrompt() {
  const imageUploadDiv = document.getElementById('ai-creation');
  imageUploadDiv.classList.add('hidden');
  imageUploadDiv.classList.remove('visible');

  // Clear the prompt input
  const promptInput = document.getElementById('prompt-input');
  promptInput.value = '';
}




    // Function to show toast notifications
    function showToast(message, type = 'error') {
      const toastContainer = document.getElementById('toast-container');
      if (!toastContainer) {
        console.error('Toast container not found in the DOM.');
        return;
      }

      const toast = document.createElement('div');
      toast.classList.add('toast');

      if (type === 'success') {
        toast.classList.add('toast-success');
      } else {
        toast.classList.add('toast-error');
      }

      toast.textContent = message;
      toastContainer.appendChild(toast);

      // Remove the toast after 3 seconds with a fade-out animation
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.addEventListener('transitionend', () => {
          toast.remove();
        });
      }, 1000);
    }
      
      
    async function updateImageVisibility(imageId, isPublic) {
      try {
        const response = await fetch('/update-image-visibility', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ imageId, isPublic })
        });

        if (response.ok) {
          showToast(`Image visibility updated to ${isPublic ? 'public' : 'private'}!`, 'success');
          
          setTimeout(() => {
              //loadPrivatePosts();
              switchTab('profile');
          }, 500);  
            
        } else {
          showToast('Failed to update image visibility.', 'error');
        }
      } catch (error) {
        console.error('Error updating image visibility:', error);
        showToast('An error occurred while updating image visibility.', 'error');
      }
    }

      



    document.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('status') === 'success') {
            showToast('Payment successful! Tokens have been added to your account.', 'success');
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
          
          document.getElementById('post-comment').addEventListener('click', async () => {
              const commentInput = document.getElementById('comment-input');
              const commentText = commentInput.value.trim();
              const imageId = window.currentImageId;

              console.log('Posting comment for image ID:', imageId); // Debugging

              if (!commentText) {
                showToast('Please enter a comment.', 'error');
                return;
              }

              if (!imageId) {
                showToast('Invalid image ID. Please refresh the page and try again.', 'error');
                return;
              }

              try {
                const response = await fetch(`/images/${imageId}/comments`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ content: commentText }),
                });

                if (!response.ok) {
                  throw new Error('Failed to post comment.');
                }

                const newComment = await response.json();

                const commentsList = document.getElementById('comments-list');
                const li = document.createElement('li');
                li.classList.add('flex', 'items-start', 'space-x-2');
                li.innerHTML = `
                  <div class="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center">
                    <img
                      src="${newComment.avatar}"
                      alt="${newComment.username}"
                      class="w-full h-full rounded-full"
                      onerror="this.style.display='none';"
                    />
                    <i class="fas fa-user text-white text-sm"></i> <!-- FontAwesome user icon -->
                  </div>
                  <div>
                    <p class="font-bold text-black">${newComment.username}</p>
                    <p class="text-gray-600">${newComment.content}</p>
                  </div>
                `;
                commentsList.appendChild(li);

                // Clear the comment input field
                commentInput.value = '';
                showToast('Comment posted successfully!', 'success');
              } catch (error) {
                console.error('Error posting comment:', error);
                showToast('Failed to post your comment. Please try again.', 'error');
              }
            });

            document.addEventListener('keydown', (event) => {
              if (event.key === 'Escape') {
                commentsModal.classList.add('hidden'); // Hide the modal
              }
            });

          
          const commentsModal = document.getElementById('comments-modal');
  const closeModalButton = document.getElementById('close-comments-modal');
  const modalImage = document.getElementById('modal-image');
  const fullscreenIcon = document.getElementById('fullscreen-icon');

  let scrollPosition = 0; // Store the scroll position globally

  // Function to disable scrolling
  const disableScrolling = () => {
    scrollPosition = window.scrollY; // Save current scroll position
    document.body.style.overflow = 'hidden';
    document.body.style.position = 'fixed';
    document.body.style.width = '100%';
    document.body.style.top = `-${scrollPosition}px`;
  };

  // Function to enable scrolling
  const enableScrolling = () => {
    document.body.style.overflow = '';
    document.body.style.position = '';
    document.body.style.width = '';
    document.body.style.top = '';
    window.scrollTo(0, scrollPosition); // Restore the saved scroll position
  };

  // Close the comments modal
  const closeCommentsModal = () => {
    commentsModal.classList.add('hidden');
    enableScrolling(); // Re-enable scrolling
    history.pushState(null, '', window.location.origin);
  };

  // Close the comments modal when "x" is clicked
  closeModalButton.addEventListener('click', closeCommentsModal);

  // Close the comments modal when clicking outside it
  commentsModal.addEventListener('click', (event) => {
    if (event.target === commentsModal) {
      closeCommentsModal();
    }
  });

  // Add escape key functionality for the comments modal
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && !commentsModal.classList.contains('hidden')) {
      closeCommentsModal();
    }
  });

  // Fullscreen Modal Function
  const showFullscreenModal = () => {
    disableScrolling(); // Disable scrolling when entering fullscreen

    // Create fullscreen container
    const fullScreenModal = document.createElement('div');
    fullScreenModal.classList.add('fullscreen-modal');

    // Create the image container with close button
    const imageContainer = document.createElement('div');
    imageContainer.classList.add('relative');

    // Create the fullscreen image
    const fullscreenImage = document.createElement('img');
    fullscreenImage.src = modalImage.src;
    fullscreenImage.alt = "Full Image";
    fullscreenImage.classList.add('fullscreen-image');

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '&times;';
    closeButton.classList.add(
      'absolute',
      'top-4',
      'right-4',
      'bg-red-500',
      'hover:bg-red-600',
      'text-white',
      'text-2xl',
      'px-3',
      'py-1',
      'rounded-full',
      'shadow-lg',
      'transition-colors'
    );

    // Assemble the modal
    imageContainer.appendChild(fullscreenImage);
    imageContainer.appendChild(closeButton);
    fullScreenModal.appendChild(imageContainer);
    document.body.appendChild(fullScreenModal);

    // Handle closing the fullscreen view
    const closeFullscreen = () => {
      enableScrolling(); // Re-enable scrolling when exiting fullscreen
      fullScreenModal.classList.add('opacity-0');
      setTimeout(() => fullScreenModal.remove(), 300);
    };

    // Close on button click
    closeButton.addEventListener('click', (e) => {
      e.stopPropagation();
      closeFullscreen();
    });

    // Close on background click
    fullScreenModal.addEventListener('click', (e) => {
      if (e.target === fullScreenModal) {
        closeFullscreen();
      }
    });

    // Close on escape key
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        closeFullscreen();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  };
   /*
  // Attach event listeners
  modalImage.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent closing the comments modal
    showFullscreenModal();
  });

  fullscreenIcon.addEventListener('click', (e) => {
    e.stopPropagation();
    showFullscreenModal();
  });*/
});

      
      


document.addEventListener('DOMContentLoaded', async () => {
      
  const commentInput = document.getElementById('comment-input');
  const postCommentButton = document.getElementById('post-comment');

  try {
    const response = await fetch('/user-data'); // Fetch user data
    const userData = await response.json();

    if (!userData.loggedIn) {
      commentInput.disabled = true; // Disable the input box
      commentInput.placeholder = 'Please log in to comment';
      postCommentButton.disabled = true;
    }
  } catch (error) {
    console.error('Error checking login status:', error);
  }
    
      
});

document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch("/check-auth", { method: "GET" });
  const data = await response.json();

  const promptInput = document.getElementById("prompt-input");
  
  if (!data.isAuthenticated) {
    // Disable prompt box and button
    promptInput.disabled = true;
  

    // Add placeholder text to indicate the user must log in
    promptInput.placeholder = "Please log in to create images.";
  }
});


                
// Event listener for the search button
document.getElementById('search-button').addEventListener('click', () => {
  triggerSearch();
});

// Event listener for the "Enter" key in the search input field
document.getElementById('search-query').addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    event.preventDefault(); // Prevent the default behavior of the Enter key
    triggerSearch();
  }
});

// Function to trigger the search
function triggerSearch() {  
  const query = document.getElementById('search-query').value.trim();

  if (!query) {
    showToast('Please enter a search query.', 'warning');
    return;
  }

  // Reset state for new search
  page = 1; // Start from the first page
  hasMoreImages = true; // Allow fetching of additional results
  isLoading = false; // Reset loading state

  // Clear the image list container
  const imageList = document.getElementById('image-list');
  if (imageList) {
    imageList.innerHTML = ''; // Clear previous results
  }

  // Construct the API endpoint for the search query
  const apiEndpoint = `/api/search?query=${encodeURIComponent(query)}&type=${activeFilters['image-source'] || 'ai-generated'}&style=${activeFilters['art-styles'] || 'all-styles'}&sort=${activeFilters['advanced'] || 'newest'}&page=${page}&limit=10`;

  // Make the search-results-toggle tab visible and active
  const searchResultsToggle = document.getElementById('search-results-toggle');
  const publicToggle = document.getElementById('public-toggle');
  const profileToggle = document.getElementById('profile-toggle');

  // Update toggle button visibility and active state
  publicToggle.classList.remove('selected-toggle');
  profileToggle.classList.remove('selected-toggle');
  searchResultsToggle.classList.remove('hidden');
  searchResultsToggle.classList.add('selected-toggle');

  // Log the query and API endpoint for debugging
  console.log('Performing search with query:', query);
  console.log('API endpoint:', apiEndpoint);

  // Load search results into the image list
  loadImages(apiEndpoint, 'search');
}


// Handle Search Results Toggle Button
document.getElementById('search-results-toggle').addEventListener('click', () => {
  // Make sure the search tab is active
  const searchResultsToggle = document.getElementById('search-results-toggle');
  const publicToggle = document.getElementById('public-toggle');
  const profileToggle = document.getElementById('profile-toggle');

  publicToggle.classList.remove('selected-toggle');
  profileToggle.classList.remove('selected-toggle');
  searchResultsToggle.classList.add('selected-toggle');
});





function simulateProgress(progressBar) {
  let progress = 0;
  const interval = setInterval(() => {
    progress += 10; // Increment progress
    progressBar.style.width = `${progress}%`;

    if (progress >= 100) {
      clearInterval(interval); // Stop simulation once complete
    }
  }, 200); // Update every 200ms
}


    
document.getElementById('image-upload-form').addEventListener('submit', async (event) => {
  event.preventDefault();

  if (!window.isLoggedIn) {
    showToast('Please log in to upload an image.', 'error');
    return;
  }
    

  const fileInput = document.getElementById('image-file');
  const descriptionInput = document.getElementById('image-description');

  const formData = new FormData();
  formData.append('image', fileInput.files[0]);
  formData.append('description', descriptionInput.value || '');

  
    
  try {
    await uploadImageWithProgress(formData);
      
    if (activeTab !== 'profile') {      
      // Perform the actual tab switching
      await switchTab('profile'); // Switch to profile view if not already done      
      await delay(2000);
      msnry.layout();    
    }
      
  } catch (error) {
    console.error('Error uploading image:', error);
    showToast('An error occurred while uploading the image.', 'error');
  }
});






async function uploadImageWithProgress(formData) {
  const progressBar = document.getElementById('upload-progress-bar');
  const status = document.getElementById('upload-status');

  try {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', '/upload-image', true);

    xhr.upload.onprogress = (event) => {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        progressBar.style.width = `${percentComplete}%`;
        status.textContent = `Uploading... ${Math.round(percentComplete)}%`;
      }
    };

    xhr.onload = () => {
      if (xhr.status === 200) {
        status.textContent = 'Upload successful!';
        
        // Perform the actual tab switching
        switchTab('profile'); // Switch to profile view if not already done
        

      } else {
        status.textContent = 'Upload failed.';
        
      }
    };

    xhr.onerror = () => {
      status.textContent = 'Upload error.';
      
    };

    xhr.send(formData);
  } catch (error) {    
    status.textContent = 'Upload failed.';
  }
}
      
      
      
// Track active selections for each category
const activeFilters = {
  'image-source': 'ai-generated',
  'art-styles': 'all-styles',
  'advanced': 'newest',
};

// Handle filter button clicks
document.querySelectorAll('.filter-button').forEach(button => {
  button.addEventListener('click', () => {
    const category = button.dataset.category;
    const filter = button.dataset.filter || button.dataset.subfilter || button.dataset.advanced;

    // Update activeFilters for the current category
    activeFilters[category] = filter;

    // Update UI: Clear selected class from other buttons in the same category
    document.querySelectorAll(`.filter-button[data-category="${category}"]`).forEach(btn => {
      btn.classList.remove('selected');
    });

    // Mark the clicked button as selected
    button.classList.add('selected');

    // Apply all active filters
    applyFilters();
  });
});

// Function to apply all active filters
function applyFilters() {
  // Only apply filters if the active tab is 'public' or 'search'
  if (activeTab !== 'public' && activeTab !== 'search') {
    return;
  }

  // Map the active filters correctly
  const type = activeFilters['image-source'] || 'ai-generated'; // Default to "ai-generated"
  const style = activeFilters['art-styles'] || 'all-styles'; // Default to "All Styles"
  const sort = activeFilters['advanced'] || 'newest'; // Default to "Newest"

  // Reset flags for a new query
  isLoading = false;
  hasMoreImages = true;
  page = 1;

  // Clear the image list for the new filter results
  const imageList = document.getElementById('image-list');
  if (imageList) {
    imageList.innerHTML = '';
  }

  // Construct the API endpoint
  const apiEndpoint = `/api/public-posts?type=${type}&style=${style}&sort=${sort}`;

  // Trigger loading images with the new filters
  loadImages(apiEndpoint, activeTab);
}




document.addEventListener('DOMContentLoaded', () => {
  // Set default selections
  const imageSourceButton = document.querySelector('[data-category="image-source"][data-filter="ai-generated"]');
  if (imageSourceButton) imageSourceButton.classList.add('selected');

  const artStylesButton = document.querySelector('[data-category="art-styles"][data-subfilter="all-styles"]');
  if (artStylesButton) artStylesButton.classList.add('selected');

  const advancedButton = document.querySelector('[data-category="advanced"][data-advanced="newest"]');
  if (advancedButton) advancedButton.classList.add('selected');

  // Apply default filters
  applyFilters();
});

      
      

      
      
      

// Function to validate and adjust dimensions
function validateAndAdjustDimensions(width, height, model) {
  const minSize = 256;
  const multiple = 64;

  // Determine the max size based on the selected model
  const isFluxModel = model.toLowerCase().includes('flux'); // Check if the model is a FLUX model
  const maxSize = isFluxModel ? 1280 : 1536; // Set max size to 1280 for FLUX models, 1536 for others

  // Ensure width is a multiple of 64 and within the range
  width = Math.max(minSize, Math.min(maxSize, width));
  width = Math.round(width / multiple) * multiple;

  // Ensure height is a multiple of 64 and within the range
  height = Math.max(minSize, Math.min(maxSize, height));
  height = Math.round(height / multiple) * multiple;

  return { width, height };
}

document.addEventListener('DOMContentLoaded', () => {
  // Default options
  const options = JSON.parse(localStorage.getItem('options')) || {
    width: 800,
    height: 600,
    guidanceScale: 10,
    inferenceSteps: 28,
    imageStrength: 0.75,
    lockAspectRatio: true, // Default to locked aspect ratio
    aspectRatio: '1:1', // Default aspect ratio
  };

  // Get input elements
  const widthSlider = document.getElementById('width-slider');
  const widthValue = document.getElementById('width-value');
  const heightSlider = document.getElementById('height-slider');
  const heightValue = document.getElementById('height-value');
  const guidanceScaleInput = document.getElementById('guidance-scale-modal');
  const guidanceScaleValue = document.getElementById('guidance-scale-value');
  const inferenceStepsInput = document.getElementById('inference-steps-modal');
  const inferenceStepsValue = document.getElementById('inference-steps-value');
  const imageStrengthInput = document.getElementById('image-strength-modal');
  const imageStrengthValue = document.getElementById('image-strength-value');
  const tokenCostDisplay = document.getElementById('token-cost-display');
  const styleSelect = document.getElementById('style-select');
  const modelSelect = document.getElementById('model-select');
  const resetButton = document.getElementById('reset-options');
  const lockAspectRatioCheckbox = document.getElementById('lock-aspect-ratio');

  // Get the custom dropdown elements
  const aspectRatioSelect = document.getElementById('aspect-ratio-select');
  const selectedOption = aspectRatioSelect.querySelector('.selected-option span');
  const dropdownOptions = aspectRatioSelect.querySelectorAll('.dropdown-options li');

  // Aspect ratio map
  const ratioMap = {
    '1:1': 1,
    '4:3': 4 / 3,
    '3:4': 3 / 4,
    '16:9': 16 / 9,
    '9:16': 9 / 16,
  };

  // Function to calculate token cost
  function calculateTokenCost(width, height, model) {
    const pixelCount = width * height;

    // Define token cost per 1 million pixels for each model
    const tokenCostPerMillionPixels = {
      'flux-schnell': 1, // 1 Token per 1M pixels
      'flux-dev': 1, // 1 Token per 1M pixels
      'essential-v2': 20, // 20 Tokens per 1M pixels
      // Stable Diffusion and other models: 0.1 Tokens per 1M pixels
    };

    // Get the token cost per 1M pixels for the selected model (default to 0.1 if not found)
    const tokenRate = tokenCostPerMillionPixels[model] || 0.1;

    // Calculate token cost: (pixelCount / 1,000,000) * tokenRate
    const tokenCost = (pixelCount / 1000000) * tokenRate;

    return tokenCost;
  }

  // Function to update token cost display
  function updateTokenCost() {
    const width = parseInt(widthSlider.value, 10);
    const height = parseInt(heightSlider.value, 10);
    const model = modelSelect.value;

    const tokenCost = calculateTokenCost(width, height, model);
    tokenCostDisplay.textContent = `${tokenCost.toFixed(2)} Tokens`;
  }

  // Function to validate and adjust dimensions
  function validateAndAdjustDimensions(width, height, model) {
    const minSize = 256;
    const multiple = 64;

    // Determine the max size based on the selected model
    const isFluxModel = model.toLowerCase().includes('flux'); // Check if the model is a FLUX model
    const maxSize = isFluxModel ? 1280 : 1536; // Set max size to 1280 for FLUX models, 1536 for others

    // Ensure width is a multiple of 64 and within the range
    width = Math.max(minSize, Math.min(maxSize, width));
    width = Math.round(width / multiple) * multiple;

    // Ensure height is a multiple of 64 and within the range
    height = Math.max(minSize, Math.min(maxSize, height));
    height = Math.round(height / multiple) * multiple;

    return { width, height };
  }

  // Function to update the selected aspect ratio
  function updateSelectedAspectRatio(value) {
    // Update the selected option text
    selectedOption.textContent = value;

    // Close the dropdown (optional)
    aspectRatioSelect.classList.remove('open');

    // Update dimensions based on the new aspect ratio
    updateDimensions(value);
  }

  // Add click event listeners to the dropdown options
  dropdownOptions.forEach(option => {
    option.addEventListener('click', () => {
      const value = option.getAttribute('data-value');
      updateSelectedAspectRatio(value);
    });
  });

  // Function to get the current selected aspect ratio
  function getSelectedAspectRatio() {
    return selectedOption.textContent;
  }

  // Function to update dimensions based on aspect ratio
  function updateDimensions(selectedRatio) {
    const dimensions = {
      '1:1': [1024, 1024],
      '4:3': [1024, 768],
      '3:4': [768, 1024],
      '16:9': [1280, 720],
      '9:16': [720, 1280],
    };

    let [width, height] = dimensions[selectedRatio];

    // Validate and adjust dimensions
    const model = modelSelect.value;
    const adjustedDimensions = validateAndAdjustDimensions(width, height, model);
    width = adjustedDimensions.width;
    height = adjustedDimensions.height;

    // Update width and height sliders
    widthSlider.value = width;
    widthValue.textContent = width;
    heightSlider.value = height;
    heightValue.textContent = height;

    // Save updated dimensions to localStorage
    options.width = width;
    options.height = height;
    options.aspectRatio = selectedRatio;
    localStorage.setItem('options', JSON.stringify(options));

    // Update token cost display
    updateTokenCost();
  }

  // Function to adjust height based on width and aspect ratio
  function adjustHeightBasedOnWidth() {
    if (!lockAspectRatioCheckbox.checked) return; // Only adjust if aspect ratio is locked

    const selectedRatio = getSelectedAspectRatio();
    const ratio = ratioMap[selectedRatio];
    const width = parseInt(widthSlider.value, 10);

    // Ensure width is a valid number
    if (isNaN(width)) return;

    const height = Math.round(width / ratio);

    // Validate and adjust dimensions
    const model = modelSelect.value;
    const adjustedDimensions = validateAndAdjustDimensions(width, height, model);

    // Update height slider
    heightSlider.value = adjustedDimensions.height;
    heightValue.textContent = adjustedDimensions.height;

    // Save updated dimensions to localStorage
    options.width = adjustedDimensions.width;
    options.height = adjustedDimensions.height;
    localStorage.setItem('options', JSON.stringify(options));

    // Update token cost display
    updateTokenCost();
  }

  // Function to adjust width based on height and aspect ratio
  function adjustWidthBasedOnHeight() {
    if (!lockAspectRatioCheckbox.checked) return; // Only adjust if aspect ratio is locked

    const selectedRatio = getSelectedAspectRatio();
    const ratio = ratioMap[selectedRatio];
    const height = parseInt(heightSlider.value, 10);

    // Ensure height is a valid number
    if (isNaN(height)) return;

    const width = Math.round(height * ratio);

    // Validate and adjust dimensions
    const model = modelSelect.value;
    const adjustedDimensions = validateAndAdjustDimensions(width, height, model);

    // Update width slider
    widthSlider.value = adjustedDimensions.width;
    widthValue.textContent = adjustedDimensions.width;

    // Save updated dimensions to localStorage
    options.width = adjustedDimensions.width;
    options.height = adjustedDimensions.height;
    localStorage.setItem('options', JSON.stringify(options));

    // Update token cost display
    updateTokenCost();
  }

  // Update slider values when they change
  widthSlider.addEventListener('input', () => {
    widthValue.textContent = widthSlider.value;
    adjustHeightBasedOnWidth();
  });

  heightSlider.addEventListener('input', () => {
    heightValue.textContent = heightSlider.value;
    adjustWidthBasedOnHeight();
  });

  // Handle guidance scale input
  guidanceScaleInput.addEventListener('input', () => {
    guidanceScaleValue.textContent = guidanceScaleInput.value;
    options.guidanceScale = parseFloat(guidanceScaleInput.value);
    localStorage.setItem('options', JSON.stringify(options));
  });

  // Handle inference steps input
  inferenceStepsInput.addEventListener('input', () => {
    inferenceStepsValue.textContent = inferenceStepsInput.value;
    options.inferenceSteps = parseInt(inferenceStepsInput.value, 10);
    localStorage.setItem('options', JSON.stringify(options));
  });

  // Handle image strength input
  imageStrengthInput.addEventListener('input', () => {
    imageStrengthValue.textContent = imageStrengthInput.value;
    options.imageStrength = parseFloat(imageStrengthInput.value);
    localStorage.setItem('options', JSON.stringify(options));
  });

  // Handle form submission
  document.getElementById('options-form').addEventListener('submit', (e) => {
    e.preventDefault();

    // Validate and adjust dimensions before saving
    const model = modelSelect.value;
    const width = parseInt(widthSlider.value, 10);
    const height = parseInt(heightSlider.value, 10);
    const adjustedDimensions = validateAndAdjustDimensions(width, height, model);

    // Save options to localStorage
    options.width = adjustedDimensions.width;
    options.height = adjustedDimensions.height;
    options.guidanceScale = parseFloat(guidanceScaleInput.value);
    options.inferenceSteps = parseInt(inferenceStepsInput.value, 10);
    options.imageStrength = parseFloat(imageStrengthInput.value);
    options.aspectRatio = getSelectedAspectRatio();
    options.lockAspectRatio = lockAspectRatioCheckbox.checked;

    localStorage.setItem('options', JSON.stringify(options));

    showToast('Options saved successfully!', 'success');

    // Close the modal
    closeModal('options-modal');
  });

  
// Reset button functionality
resetButton.addEventListener('click', () => {
  // Reset to default values
  widthSlider.value = 800;
  widthValue.textContent = 800;
  heightSlider.value = 600;
  heightValue.textContent = 600;
  guidanceScaleInput.value = 10;
  guidanceScaleValue.textContent = 10;
  inferenceStepsInput.value = 28;
  inferenceStepsValue.textContent = 28;
  imageStrengthInput.value = 0.75;
  imageStrengthValue.textContent = 0.75;

  // Uncheck the "Lock Aspect Ratio" checkbox
  lockAspectRatioCheckbox.checked = false;

  // Update the selected aspect ratio text (without triggering dimension changes)
  selectedOption.textContent = '1:1';

  // Save reset values to localStorage
  options.width = 800;
  options.height = 600;
  options.guidanceScale = 10;
  options.inferenceSteps = 28;
  options.imageStrength = 0.75;
  options.lockAspectRatio = false; // Save the unchecked state
  options.aspectRatio = '1:1';
  localStorage.setItem('options', JSON.stringify(options));

  // Update token cost display
  updateTokenCost();
});
  // Update token cost when style or model changes
  styleSelect.addEventListener('change', () => {
    const selectedStyle = styleSelect.value;

    // Normalize the value to lowercase for comparison
    if (!selectedStyle || selectedStyle.toLowerCase() === "all-styles" || selectedStyle.toLowerCase() === "select-a-style") {
      // Default back to Flux model when no specific style is selected
      populateModelDropdownForImageSelection(""); // Pass an empty string to trigger the Flux model
    } else {
      // Populate the model dropdown based on the selected style
      populateModelDropdownForImageSelection(selectedStyle);
    }

    // Update token cost after changing the model
    updateTokenCost();
  });

  modelSelect.addEventListener('change', updateTokenCost);

  // Initial token cost calculation
  updateTokenCost();
});
      
// Function to check if the user is registered
document.addEventListener('DOMContentLoaded', () => {
  const welcomeModal = document.getElementById('welcome-modal');
  const closeWelcomeModal = document.getElementById('close-welcome-modal');
  const registerWithGoogleButton = document.getElementById('register-with-google');

  // Check if the user has already seen the modal
  const hasSeenWelcomeModal = localStorage.getItem('hasSeenWelcomeModal');

  // Fetch user data to check if the user is registered
  fetch('/user-data')
    .then(response => response.json())
    .then(data => {
      if (!data.isRegistered && !hasSeenWelcomeModal) {
        welcomeModal.classList.remove('hidden'); // Show the modal for unregistered users
      }
    })
    .catch(error => {
      console.error('Error fetching user data:', error);
    });

  // Close the modal and set a flag in localStorage
  closeWelcomeModal.addEventListener('click', () => {
    welcomeModal.classList.add('hidden');
    localStorage.setItem('hasSeenWelcomeModal', 'true'); // Remember that the user has seen the modal
  });

  // Redirect to Google OAuth for registration
  registerWithGoogleButton.addEventListener('click', () => {
    localStorage.setItem('hasSeenWelcomeModal', 'true'); // Remember that the user has seen the modal
    window.location.href = '/auth/google'; // Redirect to Google OAuth
  });
}); 
    
document.addEventListener('DOMContentLoaded', () => {
  const dropdown = document.getElementById('aspect-ratio-select');
  const selectedOption = dropdown.querySelector('.selected-option');
  const options = dropdown.querySelectorAll('.dropdown-options li');

  // Open/close dropdown
  selectedOption.addEventListener('click', () => {
    dropdown.classList.toggle('open');
    const optionsElement = dropdown.querySelector('.dropdown-options');
    optionsElement.hidden = !optionsElement.hidden; // Toggle visibility
  });

  // Handle option selection
  options.forEach(option => {
    option.addEventListener('click', () => {
      const value = option.getAttribute('data-value');
      const icon = option.querySelector('i').className;
      const text = option.querySelector('span').textContent;

      // Update selected option display
      selectedOption.innerHTML = `
        <i class="${icon}"></i>
        <span>${text}</span>
        <i class="fas fa-chevron-down"></i>
      `;

      // Set the value of the custom dropdown
      dropdown.setAttribute('data-value', value);

      // Close dropdown
      dropdown.classList.remove('open');
      dropdown.querySelector('.dropdown-options').hidden = true;

      // Trigger any existing code that relies on the selected value
      const event = new Event('change');
      dropdown.dispatchEvent(event);
    });
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!dropdown.contains(e.target)) {
      dropdown.classList.remove('open');
      dropdown.querySelector('.dropdown-options').hidden = true;
    }
  });

  // Emulate the native select element's value property
  Object.defineProperty(dropdown, 'value', {
    get() {
      return this.getAttribute('data-value');
    },
    set(value) {
      const option = Array.from(options).find(opt => opt.getAttribute('data-value') === value);
      if (option) {
        option.click(); // Simulate a click on the option to update the UI
      }
    },
  });
});
      
      
document.addEventListener('DOMContentLoaded', () => {
  const sidebar = document.getElementById('filter-sidebar');
  const backdrop = document.getElementById('sidebar-backdrop');
  const openSidebarButton = document.getElementById('open-filters-button');
  const closeSidebarButton = document.getElementById('close-sidebar');
  const closeSidebarBottomButton = document.getElementById('close-sidebar-bottom');
  let closeTimeout;
  let touchStartX = 0;
  let touchEndX = 0;
  const SWIPE_THRESHOLD = 50;
  const EDGE_THRESHOLD = 30;
  const AUTO_CLOSE_DELAY = 300;

  // Open Sidebar
  function openSidebar(event) {
    if (event) event.stopPropagation();
    sidebar.classList.remove('hidden');
    sidebar.classList.add('open');
    backdrop.style.display = 'block';
    requestAnimationFrame(() => {
      backdrop.style.opacity = '1';
    });
  }

  // Close Sidebar
  function closeSidebar(event) {
    if (event) event.stopPropagation();
    sidebar.classList.remove('open');
    backdrop.style.opacity = '0';
    setTimeout(() => {
      sidebar.classList.add('hidden');
      backdrop.style.display = 'none';
    }, 300);
  }

  // Track mouse position and auto-close behavior
  const handleMouseMove = (() => {
    let lastMouseX = 0;
    let isMouseNearSidebar = false;

    return (e) => {
      lastMouseX = e.clientX;
      isMouseNearSidebar = lastMouseX <= (sidebar.offsetWidth + EDGE_THRESHOLD);

      // If sidebar is open and mouse moves far right, consider closing
      if (sidebar.classList.contains('open') && !isMouseNearSidebar) {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(() => {
          if (!isMouseNearSidebar && lastMouseX > sidebar.offsetWidth + EDGE_THRESHOLD) {
            closeSidebar();
          }
        }, AUTO_CLOSE_DELAY);
      }
    };
  })();

  // Handle touch events for both opening and closing
  function handleTouchStart(e) {
    touchStartX = e.touches[0].clientX;
    touchEndX = touchStartX; // Reset end position
  }

  function handleTouchMove(e) {
    touchEndX = e.touches[0].clientX;
  }

  function handleTouchEnd() {
    const swipeDistance = touchEndX - touchStartX;
    const isOpen = sidebar.classList.contains('open');

    // Open on right swipe from edge
    if (!isOpen && swipeDistance > SWIPE_THRESHOLD && touchStartX < EDGE_THRESHOLD) {
      openSidebar();
    }
    // Close on left swipe when open
    else if (isOpen && swipeDistance < -SWIPE_THRESHOLD) {
      closeSidebar();
    }
  }

  // Handle clicks outside sidebar
  function handleOutsideClick(e) {
    if (sidebar.classList.contains('open') &&
        !sidebar.contains(e.target) && 
        !openSidebarButton.contains(e.target)) {
      closeSidebar();
    }
  }

  // Event Listeners
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('click', handleOutsideClick);
  document.addEventListener('touchstart', handleTouchStart, { passive: true });
  document.addEventListener('touchmove', handleTouchMove, { passive: true });
  document.addEventListener('touchend', handleTouchEnd);

  sidebar.addEventListener('mouseenter', () => clearTimeout(closeTimeout));
  openSidebarButton.addEventListener('click', openSidebar);
  closeSidebarButton.addEventListener('click', closeSidebar);
  closeSidebarBottomButton.addEventListener('click', closeSidebar);
  backdrop.addEventListener('click', closeSidebar);

  // Prevent clicks inside sidebar from closing it
  sidebar.addEventListener('click', (event) => {
    event.stopPropagation();
  });
});
      
// Variables to track zoom state
let scale = 1;
let initialDistance = null;

// Handle Touch Start (for pinch-to-zoom)
function handleTouchStart(event) {
  if (event.touches.length === 2) {
    // Calculate the initial distance between two fingers
    initialDistance = Math.hypot(
      event.touches[0].clientX - event.touches[1].clientX,
      event.touches[0].clientY - event.touches[1].clientY
    );
  }
}

// Handle Touch Move (for pinch-to-zoom)
function handleTouchMove(event) {
  if (event.touches.length === 2) {
    event.preventDefault(); // Prevent default scrolling behavior

    // Calculate the current distance between two fingers
    const currentDistance = Math.hypot(
      event.touches[0].clientX - event.touches[1].clientX,
      event.touches[0].clientY - event.touches[1].clientY
    );

    // Calculate the scale factor
    if (initialDistance !== null) {
      scale = currentDistance / initialDistance;
      const fullscreenImage = document.getElementById('fullscreen-image');
      fullscreenImage.style.transform = `scale(${scale})`;
    }
  }
}

// Handle Touch End (reset initial distance)
function handleTouchEnd() {
  initialDistance = null;
}

// Handle Orientation Change
function handleOrientationChange() {
  const fullscreenImage = document.getElementById('fullscreen-image');
  if (fullscreenImage) {
    // Reset zoom and position on orientation change
    scale = 1;
    fullscreenImage.style.transform = `scale(${scale})`;
  }
}
      
function autoResizeTextarea(textarea) {
  textarea.style.height = 'auto'; // Reset height to auto to calculate the new height
  textarea.style.height = `${Math.min(textarea.scrollHeight, textarea.dataset.maxHeight || 160)}px`;
}

const promptInput = document.getElementById('prompt-input');
if (promptInput) {
  promptInput.dataset.maxHeight = 160; // Set a maximum height (optional)
  promptInput.addEventListener('input', () => {
    autoResizeTextarea(promptInput);
  });
  autoResizeTextarea(promptInput); // Initial resize
}
function adjustTextareaHeight() {
  const promptInput = document.getElementById('prompt-input');
  if (window.matchMedia("(orientation: landscape)").matches) {
    // Landscape mode
    promptInput.style.maxHeight = '100px'; // Smaller height for landscape
  } else {
    // Portrait mode
    promptInput.style.maxHeight = '300px'; // Larger height for portrait
  }
}

// Listen for orientation changes
window.addEventListener('orientationchange', adjustTextareaHeight);

window.addEventListener('resize', () => {
  msnry.layout();
  adjustTextareaHeight();       
});

      
document.addEventListener('DOMContentLoaded', () => {
    
    const urlParams = new URLSearchParams(window.location.search);
    const imageId = urlParams.get('image');
    
    if (imageId) {
        
        fetch(`/api/image-details/${imageId}`)
            .then(response => {
                console.log('Fetch response:', response);
                if (!response.ok) {
                    showToast('The requested image could not be found or is no longer available.', 'error');
                    throw new Error('Image not found');
                }
                return response.json();
            })
            .then(data => {
                console.log('Fetch data:', data);
                if (data) {
                    openCommentsModal(imageId, data.imageUrl, data.isPublic ? 'public' : 'personal');
                } else {
                    console.error('Image details could not be found.');
                    showToast('The image details could not be loaded. Please try again later.', 'error');
                }
            })
            .catch(error => {
                console.error('Error fetching image details:', error);
                showToast('An error occurred while loading the image. Please try again later.', 'error');
            });
    } 
});
  </script>
</body>
</html>
