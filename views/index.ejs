<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pixzor</title>
  <!-- Tailwind CSS CDN -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.16/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

  <style>
    /* Custom styles for the fixed prompt box */
    .fixed-prompt {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 1200px;
      z-index: 10;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
      background-color: #1a1a1a; /* Dark background for prompt box */
      border-radius: 12px 12px 0 0;
      padding: 20px;
    }

    /* Add padding to the main content to prevent overlap with the fixed prompt box */
    .content-padding {
      padding-bottom: 300px; /* Adjust based on the prompt box height */
      padding-top: 60px; /* Adjust based on the height of your navbar */
    }

    /* Button styles */
    .custom-button {
      background-color: #4b5563; /* Gray color */
      color: white;
      transition: background-color 0.3s;
    }

    .custom-button:hover {
      background-color: #10b981; /* Green color on hover */
    }

    /* Modal backdrop */
    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black */
    }

    /* Logo Placeholder */
    .logo {
      width: 40px;
      height: 40px;
      background-color: #4b5563; /* Gray background */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 1.2rem;
    }

    /* Fixed Generated Images Container */
    .generated-images-container {
      max-height: 80vh;
      overflow-y: auto;
    }

    /* Selected Toggle Button Style */
    .selected-toggle {
      background-color: #a1a1aa; /* Light Gray */
      color: white;
    }

    /* Make images take full width of the container */
    #image-list img {
      width: 100%;
      height: auto;
      object-fit: cover;
    }

    /* Adjust padding or margin as needed */
    .image-card {
      padding: 0;
    }

    nav {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1); /* Light border */
      border-top: 4px solid #ffffff; /* White top for visibility */
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Badges */
    .badge-public {
      display: inline-block;
      background-color: green;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .badge-private {
      display: inline-block;
      background-color: red;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    /* Error Message Styling */
    #error-message {
      display: block;
      margin-top: 10px;
      font-size: 0.875rem;
      color: #f87171; /* Tailwind's red-400 */
    }

    /* Toast Notification Container */
    #toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
    }

    /* Toast Styles */
    .toast {
      background-color: #1f2937; /* Dark background */
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 10px;
      opacity: 0.95;
      transition: opacity 0.3s ease;
    }

    .toast-success {
      background-color: #10b981; /* Green */
    }

    .toast-error {
      background-color: #ef4444; /* Red */
    }

    .hidden {
      display: none;
    }
      
   
    #post-visibility-toggle:checked + .block {
      background-color: #10b981; 
    }
    #post-visibility-toggle:checked + .block + .dot {
      transform: translateX(4px); 
    }
      
   #post-visibility-button:hover + #post-visibility-tooltip {
      display: block;
    }
      
    .post-visibility-wrapper {
      position: relative; 
    }

    .custom-button {
      box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.2);
      transition: background-color 0.2s, box-shadow 0.2s;
    }
    .custom-button:hover {
      box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.3);
    }

    .image-card {
      position: relative;
      overflow: hidden; /* Ensures image scaling doesn't affect layout */
      border-radius: 12px; /* Matches other rounded elements */
    }

    .image-card img {
      cursor: pointer; /* Change cursor to a hand */
      transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Smooth hover effect */
    }

    .image-card:hover img {
      transform: scale(1.05); /* Slight zoom on hover */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); /* Add shadow */
    }
    .toggle-visibility-button {
      margin-left: 4px; /* Add some space between buttons */
      display: inline-block; /* Align with other buttons */
   }

</style>
</head>
<body class="bg-gray-900 text-white">
  <!-- Navbar -->
  <nav class="bg-gray-800 shadow-md fixed top-0 left-0 right-0 z-50">
    <div class="container mx-auto px-4 py-2 flex justify-between items-center">
      <!-- Logo -->
      <div class="flex items-center space-x-2">
        <img src="/images/logo.png" alt="Pixzor Logo" class="w-8 h-7">
        <span class="text-xl font-bold">Pixzor</span>
      </div>

      <div class="flex items-center space-x-4">
        <!-- Token Display and Purchase Button -->
        <button id="tokens-button" class="flex items-center bg-gray-700 hover:bg-yellow-600 px-4 py-2 rounded-lg">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-yellow-400 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
            <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM10 18a8 8 0 100-16 8 8 0 000 16z" clip-rule="evenodd" />
          </svg>
          <span id="token-count" class="text-yellow-400">Tokens: 0</span>
        </button>

        <!-- Google Auth Button -->
        <button id="google-auth-button" class="flex items-center bg-gray-700 hover:bg-green-600 px-4 py-2 rounded-lg">
          <img src="https://img.icons8.com/ios-filled/24/ffffff/google-logo.png" alt="Google" class="mr-2" />
          <span>Login / Register</span>
        </button>
      </div>
    </div>
  </nav>

  
  <!-- Fixed Container for Toggle Buttons -->
<div class="fixed left-0 right-0 z-40" style="top: 56px;"> <!-- Adjust top value as needed -->
  <div class="container mx-auto py-2 flex justify-center">
    <!-- Buttons without a distinct background layer -->
    <button id="public-toggle" class="custom-button bg-transparent text-white px-4 rounded-l-lg text-sm selected-toggle hover:bg-gray-700" style="height: 32px; border: 1px solid rgba(255, 255, 255, 0.3);">
      Public Posts
    </button>
    <button id="profile-toggle" class="custom-button bg-transparent text-white px-4 rounded-r-lg text-sm hover:bg-gray-700" style="height: 32px; border: 1px solid rgba(255, 255, 255, 0.3);">
      Profile Posts
    </button>
  </div>
</div>

  <!-- Main Container -->
  <div class="container mx-auto py-20 content-padding">
    <!-- Add padding to compensate for the fixed buttons -->
    <div id="error-message" class="text-red-500 text-center mb-4"></div>

    <!-- Main Content Container with Padding -->
    <div id="image-list" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-4">
      <!-- Images will be dynamically added here -->
    </div>
  </div>

 
    
    
    
    
    
    <!-- Fixed Prompt and Buttons at the Bottom -->
<div class="fixed-prompt bg-gray-800 rounded-t-lg shadow-md">
  <div class="container mx-auto">
    <!-- Prompt Input -->
    <div class="flex flex-col md:flex-row items-center md:space-x-4">
      <!-- Prompt Input -->
      <div class="mb-4 md:mb-0 flex-grow">
        <textarea id="prompt-input" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" rows="2" placeholder="Enter your prompt"></textarea>
      </div>
    </div>

    <!-- Prompt Options and Generate Button -->
    <div class="flex flex-col md:flex-row justify-between mt-4 space-y-2 md:space-y-0">
      <div class="flex space-x-2">
          
        <button id="options-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Options</button>
        
        <!--  
        <button id="enhance-prompt-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Enhance Prompt</button>
          
        <button id="setup-character-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Add Character</button>

        
        <div class="flex justify-center mb-4">
          <select id="character-select" class="w-full max-w-xs bg-gray-700 rounded-lg py-1 px-0 text-white" aria-label="Select Character">
            <option value="" disabled selected>Select Character</option>
            
          </select>
        </div> 
          -->
          
      </div> 
       
        
      
    <!-- Post Visibility Toggle and Generate Button -->
<div class="flex items-center space-x-2">
  <!-- Visibility Text -->
  <span id="post-visibility-text" class="ml-2 text-white">Post Public</span>
  
    
  <!-- Post Visibility Button and Tooltip Wrapper -->
  <div class="relative flex items-center"> <!-- Added "relative" to the container -->
    <button id="post-visibility-button" class="bg-gray-700 text-white px-2 py-2 rounded-lg hover:bg-gray-600 focus:outline-none">
      <!-- Eye Icon -->
      <svg id="post-visibility-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <!-- Initial "eye" icon -->
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.522 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" />
      </svg>
    </button>

    <!-- Tooltip Element -->
    <span id="post-visibility-tooltip" class="absolute bottom-12 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 whitespace-nowrap hidden">
      Create in public
    </span>
  </div>

  <!-- Generate Image Button -->
  <button id="generate-button" class="bg-green-700 hover:bg-green-600 text-white font-medium px-4 rounded-lg text-sm" style="height: 32px;">Generate Image</button>
</div>
        
    </div>
  </div>
</div>

  
<!-- Buy Tokens Modal -->
<div id="buy-tokens-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="buy-tokens-modal-title">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-200 border-2 border-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="close-buy-tokens-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">&times;</button>
      <h2 id="buy-tokens-modal-title" class="text-xl font-bold mb-4 text-gray-900">Buy Tokens</h2>
      <div class="text-center text-gray-700">
        <p class="text-lg">This feature is currently under development.</p>
        <p>Please check back later for updates.</p>
      </div>
    </div>
  </div>
</div>

<!-- Options Modal -->
<div id="options-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="options-modal-title">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-200 border-2 border-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="close-options-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">&times;</button>
      <h2 id="options-modal-title" class="text-xl font-bold mb-4 text-gray-900">Options</h2>
                     
          <!-- Select Style 
          <div class="mb-4">
            <label for="style-select-modal" class="block font-medium mb-1">Select Style</label>
            <select id="style-select-modal" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white">
              <option value="" disabled selected>Choose a style</option>
              <option value="pixar">Pixar</option>
              <option value="anime">Anime</option>
              <option value="cartoon">Cartoon</option>             
            </select>
          </div>
          -->
        
      <form id="options-form">           
  <!-- Set Variables -->
  <div class="mb-4">
    <label for="width-modal" class="block font-medium mb-1 text-gray-900">Width</label>
    <input type="number" id="width-modal" value="800" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Width (e.g., 800)">
    <label for="height-modal" class="block font-medium mb-1 text-gray-900">Height</label>
    <input type="number" id="height-modal" value="600" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Height (e.g., 600)">
    <label for="guidance-scale-modal" class="block font-medium mb-1 text-gray-900">Guidance Scale</label>
    <input type="number" step="0.1" id="guidance-scale-modal" value="3.5" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Guidance Scale">
    <label for="inference-steps-modal" class="block font-medium mb-1 text-gray-900">Inference Steps</label>
    <input type="number" id="inference-steps-modal" value="4" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600" placeholder="Inference Steps">
  </div>

  <div class="flex justify-end">
    <button type="submit" class="custom-button font-medium py-2 px-4 bg-gray-700 text-white rounded-lg hover:bg-gray-600">Save Options</button>
  </div>
</form>

    </div>
  </div>
</div>
    
    

  <!-- Setup Character Modal -->
<div id="setup-character-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="setup-character-modal-title">
 
    <div class="flex items-center justify-center min-h-screen px-4">
      <div class="bg-gray-800 rounded-lg shadow-lg w-full max-w-md p-6 relative">
        <button id="close-setup-character-modal" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600" aria-label="Close">&times;</button>
        <h2 id="setup-character-modal-title" class="text-xl font-bold mb-4">Setup Character</h2>
        <form id="setup-character-form">
          <!-- Character Name -->
          <div class="mb-4">
            <label for="character-name" class="block font-medium mb-1">Character Name</label>
            <input type="text" id="character-name" name="character-name" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" required>
          </div>
          <!-- Character Description -->
          <div class="mb-4">
            <label for="character-description" class="block font-medium mb-1">Description</label>
            <textarea id="character-description" name="character-description" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" rows="4" placeholder="Describe your character"></textarea>
          </div>
          <!-- Upload Face -->
          <div class="mb-4">
            <label for="face-upload-character" class="block font-medium mb-1">Upload Face</label>
            <input type="file" id="face-upload-character" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white">
          </div>
          <div class="flex justify-end">
            <button type="submit" class="custom-button font-medium py-2 px-4 rounded-lg">Save Character</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- Toast Notification Container -->
  <div id="toast-container" class="fixed top-20 right-20 z-50"></div>

  <!-- JavaScript -->
  <script>
    // script.js
    let isPublic = false;

    document.addEventListener('DOMContentLoaded', () => {
      // Fetch user data on page load
      fetchUserData();

      // Initialize character dropdown
      populateCharacterDropdown();

      // Load public posts by default
      loadPublicPosts();

      // Set up event listeners
      setupEventListeners();
    });

    // Function to fetch user data
    async function fetchUserData() {
      try {
        const response = await fetch('/user-data');
        const data = await response.json();

        const tokenCountElement = document.getElementById('token-count');
        const googleAuthButton = document.getElementById('google-auth-button');

        if (data.loggedIn) {
          // Update the token count
          tokenCountElement.textContent = `Tokens: ${data.tokens}`;

          // Update the Google Auth button to show user info
          googleAuthButton.innerHTML = `
            <img src="${data.photo}" alt="Profile" class="mr-2 w-6 h-6 rounded-full" />
            <span>${data.username}</span>
          `;
          googleAuthButton.classList.remove('bg-gray-700');
          googleAuthButton.classList.add('bg-green-600');

          // Enable the generate button
          document.getElementById('generate-button').disabled = false;
        } else {
          // User is not logged in
          tokenCountElement.textContent = `Tokens: 0`;
          googleAuthButton.innerHTML = 'Login with Google';
          googleAuthButton.classList.remove('bg-green-600');
          googleAuthButton.classList.add('bg-gray-700');

          // Disable the generate button
          document.getElementById('generate-button').disabled = true;
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
        showToast('An error occurred while fetching user data.', 'error');
      }
    }

    // Function to set up all event listeners
    function setupEventListeners() {
      // Handle Google Authentication Button Click
      const googleAuthButton = document.getElementById('google-auth-button');
      if (googleAuthButton) {
        googleAuthButton.addEventListener('click', () => {
          // Redirect to Google OAuth endpoint
          window.location.href = '/auth/google';
        });
      }

      // Modal Elements
      const modals = {
        'options-modal': document.getElementById('options-modal'),
        'setup-character-modal': document.getElementById('setup-character-modal'),
        'buy-tokens-modal': document.getElementById('buy-tokens-modal'),
      };

      // Function to open a modal
      function openModal(modalId) {
        if (modals[modalId]) {
          modals[modalId].classList.remove('hidden');
          document.body.classList.add('overflow-hidden'); // Prevent background scrolling
        }
      }

      // Function to close a modal
      function closeModal(modalId) {
        if (modals[modalId]) {
          modals[modalId].classList.add('hidden');
          document.body.classList.remove('overflow-hidden');
        }
      }

      // Event Listeners for Opening Modals
      document.getElementById('options-button').addEventListener('click', () => openModal('options-modal'));
      //document.getElementById('setup-character-button').addEventListener('click', () => openModal('setup-character-modal'));
      document.getElementById('tokens-button').addEventListener('click', () => openModal('buy-tokens-modal'));

      // Event Listeners for Closing Modals
      document.querySelectorAll('[id^="close-"]').forEach(button => {
        button.addEventListener('click', () => {
          const modalId = button.id.replace('close-', '');
          closeModal(modalId);
        });
      });

      // Close any open modals when clicking outside the modal content
      Object.keys(modals).forEach(modalId => {
        const modal = modals[modalId];
        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              closeModal(modalId);
            }
          });
        }
      });

      // Handle Options Form Submission
      document.getElementById('options-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const style = document.getElementById('style-select-modal').value;
        const width = document.getElementById('width-modal').value;
        const height = document.getElementById('height-modal').value;
        const guidanceScale = document.getElementById('guidance-scale-modal').value;
        const inferenceSteps = document.getElementById('inference-steps-modal').value;

        // Validate inputs
        if (!width || !height || !guidanceScale || !inferenceSteps) {
          showToast('Please fill in all option fields.', 'error');
          return;
        }

        // Save options to LocalStorage
        const options = {
          style,
          width,
          height,
          guidanceScale,
          inferenceSteps,
        };

        localStorage.setItem('options', JSON.stringify(options));

        // Close the Options Modal
        closeModal('options-modal');

        showToast('Options saved successfully!', 'success');
      });

      // Handle Setup Character Form Submission
      document.getElementById('setup-character-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const name = document.getElementById('character-name').value.trim();
        const description = document.getElementById('character-description').value.trim();
        const faceUpload = document.getElementById('face-upload-character').files[0];

        if (name && description) {
          // Save to LocalStorage
          let characters = JSON.parse(localStorage.getItem('characters')) || [];
          characters.push({ name, description, faceUpload: faceUpload ? faceUpload.name : null });
          localStorage.setItem('characters', JSON.stringify(characters));

          // Update Character Dropdown
          populateCharacterDropdown();

          // Clear the form
          document.getElementById('setup-character-form').reset();

          // Close Modal
          closeModal('setup-character-modal');

          showToast('Character added successfully!', 'success');
        } else {
          showToast('Please fill in all fields.', 'error');
        }
      });

        /*
      // Handle Enhance Prompt Button Click
      document.getElementById('enhance-prompt-button').addEventListener('click', async () => {
        const prompt = document.getElementById('prompt-input').value.trim();
        if (!prompt) {
          showToast('Please enter a prompt to enhance.', 'error');
          return;
        }

        try {
          // Show loading state
          const enhanceButton = document.getElementById('enhance-prompt-button');
          enhanceButton.textContent = 'Enhancing...';
          enhanceButton.disabled = true;

          // Send prompt to backend for enhancement
          const response = await fetch('/api/enhance-prompt', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
          });

          const data = await response.json();
          if (data.enhancedPrompt) {
            document.getElementById('prompt-input').value = data.enhancedPrompt;
            showToast('Prompt enhanced successfully!', 'success');
          } else {
            showToast('Failed to enhance the prompt.', 'error');
          }
        } catch (error) {
          console.error('Error enhancing prompt:', error);
          showToast('An error occurred while enhancing the prompt.', 'error');
        } finally {
          // Reset button state
          const enhanceButton = document.getElementById('enhance-prompt-button');
          enhanceButton.textContent = 'Enhance Prompt';
          enhanceButton.disabled = false;
        }
      });*/

      // Handle Generate Image Button Click
      document.getElementById('generate-button').addEventListener('click', async () => {
        const prompt = document.getElementById('prompt-input').value.trim();
        const characterIndex = document.getElementById('character-select').value;
        const options = JSON.parse(localStorage.getItem('options')) || {};
        const dimensions = {
          width: parseInt(options.width) || 800,
          height: parseInt(options.height) || 600
        };
        const style = options.style || '';

        // Clear previous error message
        document.getElementById('error-message').textContent = '';

        // Fetch user data to check authentication
        let userData;
        try {
          const response = await fetch('/user-data');
          userData = await response.json();
        } catch (error) {
          console.error('Error fetching user data:', error);
          showToast('An error occurred. Please try again.', 'error');
          return;
        }

        if (!userData.loggedIn) {
          // Prompt user to log in
          showToast('Please log in to generate images.', 'error');
          return;
        }

        // Check Token Availability
        let currentTokens = parseInt(userData.tokens) || 0;
        if (currentTokens <= 0) {
          showToast('You have no tokens left. Please buy more tokens to generate images.', 'error');
          return;
        }

        if (!prompt) {
          showToast('Please enter a prompt.', 'error');
          return;
        }

        // Add Placeholder
        const imageList = document.getElementById('image-list');
        if (!imageList) {
          console.error('Image List container not found in the DOM.');
          showToast('An error occurred. Please try again.', 'error');
          return;
        }

        // Create a container for both placeholder and image
        const imageContainer = document.createElement('div');
        imageContainer.classList.add('relative', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

        // Style the placeholder to be slightly lighter
        imageContainer.style.backgroundColor = '#2d2d2d'; // Adjust as needed

        // Use Flexbox to center the spinner
        imageContainer.innerHTML = `
          <div class="flex justify-center items-center h-full">
            <div class="spinner"></div>
          </div>
        `;

        imageList.prepend(imageContainer);          

        let finalPrompt = prompt;

        // Append character description if a character is selected
        if (characterIndex !== "") {
          const characters = JSON.parse(localStorage.getItem('characters')) || [];
          const selectedCharacter = characters[characterIndex];
          if (selectedCharacter) {
            finalPrompt = `${selectedCharacter.description}. ${prompt}`;
          }
        }

        // Append style if selected
        if (style) {
          finalPrompt = `${finalPrompt} Style: ${style}.`;
        }

        try {
          // Show loading state
          const generateButton = document.getElementById('generate-button');
          generateButton.textContent = 'Generating...';
          generateButton.disabled = true;              
                      
          alert("isPublic:"+isPublic);
          // Send data to backend for image generation
          const response = await fetch('/generate-image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: finalPrompt,
              isPublic: isPublic,
              width: dimensions.width,
              height: dimensions.height,
              guidanceScale: parseFloat(options.guidanceScale) || 3.5,
              inferenceSteps: parseInt(options.inferenceSteps) || 4
            })
          });

          const data = await response.json();
          if (response.ok && data.imageUrl) {
            // Create image element
            const imgElement = document.createElement('img');
            imgElement.src = data.imageUrl;
            imgElement.alt = 'Generated Image';
            imgElement.classList.add('w-full', 'h-auto', 'object-cover', 'rounded-lg');

            // Hide image initially until it's fully loaded
            imgElement.style.display = 'none';
            imageContainer.appendChild(imgElement);

            // Listen for image load event
            imgElement.addEventListener('load', () => {
              imgElement.style.display = 'block'; // Show image
              // Remove spinner
              const spinner = imageContainer.querySelector('.spinner');
              if (spinner) {
                spinner.remove();
              }

              // Update Tokens Count in Navbar
              updateTokenCount(-data.tokensUsed); // Subtract tokens

              // Switch to Profile Posts after a short delay to ensure the image is visible
              setTimeout(() => {
                document.getElementById('profile-toggle').click();
              }, 500);

              showToast('Image generated successfully!', 'success');
            });

            // Handle image load error
            imgElement.addEventListener('error', () => {
              showToast('Failed to load image.', 'error');
              imageList.removeChild(imageContainer); // Remove the placeholder on error
            });
          } else {
            // Handle error message from backend
            showToast(data.error || 'Failed to generate image.', 'error');
            imageList.removeChild(imageContainer); // Remove the placeholder on failure
          }
        } catch (error) {
          console.error('Error generating image:', error);
          showToast('An error occurred while generating the image.', 'error');
          imageList.removeChild(imageContainer); // Remove the placeholder on error
        } finally {
          // Reset button state
          const generateButton = document.getElementById('generate-button');
          generateButton.textContent = 'Generate Image';
          generateButton.disabled = false;
        }
      });

      // Function to update the token count in the navbar
      function updateTokenCount(amount) {
        const tokenCountElement = document.getElementById('token-count');
        if (tokenCountElement) {
          let currentTokens = parseInt(tokenCountElement.textContent.replace('Tokens: ', '')) || 0;
          currentTokens += amount;
          tokenCountElement.textContent = `Tokens: ${currentTokens}`;

          // Optionally, update backend if needed
          // Example: send updated token count to backend
        }
      }

      // Handle Public/Profile Toggle Buttons
      document.getElementById('public-toggle').addEventListener('click', () => {
          
          // Reset pagination state when switching to Public Posts
          page = 1; // Reset the page number
          hasMoreImages = true; // Ensure hasMoreImages is set to true

          // Toggle button styles
          document.getElementById('public-toggle').classList.add('selected-toggle');
          document.getElementById('profile-toggle').classList.remove('selected-toggle');

          // Clear existing images from the list if needed
          const imageList = document.getElementById('image-list');
          if (imageList) {
            imageList.innerHTML = ''; // Clear current images to load new ones
          }

          // Load public posts
          loadPublicPosts();
        });


      document.getElementById('profile-toggle').addEventListener('click', async () => {
        // Fetch user data to check authentication
        let userData;
        try {
          const response = await fetch('/user-data');
          userData = await response.json();
        } catch (error) {
          console.error('Error fetching user data:', error);
          showToast('An error occurred. Please try again.', 'error');
          return;
        }

        if (!userData.loggedIn) {
          // Display a message prompting the user to log in
          showToast('Please log in to view your posts.', 'error');
          return;
        }

        // Toggle button styles
        document.getElementById('profile-toggle').classList.add('selected-toggle');
        document.getElementById('public-toggle').classList.remove('selected-toggle');

        // Load private/profile posts
        loadPrivatePosts();
      });

      // Handle Buy Tokens Selection
      document.querySelectorAll('.select-token-button').forEach(button => {
        button.addEventListener('click', async () => {
          const tokens = parseInt(button.getAttribute('data-tokens'));
          const price = parseFloat(button.getAttribute('data-price'));

          try {
            if (tokens === 0) {
              showToast('The Free package offers 0 tokens.', 'error');
              return;
            }

            // Initiate payment process via backend
            const response = await fetch('/buy-tokens', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tokens, price }),
            });

            const data = await response.json();

            if (response.ok) {
              showToast(`Successfully purchased ${tokens} tokens!`, 'success');
              // Update token count in navbar
              updateTokenCount(tokens);
              // Close the Buy Tokens Modal
              closeModal('buy-tokens-modal');
            } else {
              showToast(data.error || 'Failed to purchase tokens.', 'error');
            }
          } catch (error) {
            console.error('Error purchasing tokens:', error);
            showToast('An error occurred while purchasing tokens.', 'error');
          }
        });
      });

     
 



      // Accessibility: Close any open modals when focusing on the prompt input
      const promptInput = document.getElementById('prompt-input');
      if (promptInput) {
        promptInput.addEventListener('focus', () => {
          for (let modalId in modals) {
            if (!modals[modalId].classList.contains('hidden')) {
              closeModal(modalId);
            }
          }
        });
      }
    }

    // Function to populate the character dropdown
    function populateCharacterDropdown() {
      const characterSelect = document.getElementById('character-select');
      if (!characterSelect) return;

      characterSelect.innerHTML = '<option value="" disabled selected>Select Character</option>'; // Reset options

      const characters = JSON.parse(localStorage.getItem('characters')) || [];
      characters.forEach((char, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = char.name;
        characterSelect.appendChild(option);
      });
    }

  
   function showFullSizeImage(imageUrl) {
      // Create a modal element
      const modal = document.createElement('div');
      modal.classList.add('fixed', 'inset-0', 'bg-black', 'bg-opacity-75', 'flex', 'justify-center', 'items-center', 'z-50');
      modal.innerHTML = `
        <div class="relative">
          <img src="${imageUrl}" alt="Full Image" class="max-w-full max-h-screen rounded-lg">
          <button class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full" id="close-modal">&times;</button>
        </div>
      `;

      // Append modal to the document body
      document.body.appendChild(modal);

      // Add event listener to close the modal when clicking the close button or outside the image
      modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target.id === 'close-modal') {
          modal.remove();
        }
      });
    }


    
    // Function to load public posts with infinite scrolling support
    let page = 1; // Initial page number for pagination
    let isLoading = false; // Prevent multiple simultaneous requests
    let hasMoreImages = true; // Track if there are more images to load


    async function loadPublicPosts() {
      if (isLoading || !hasMoreImages) return;
      isLoading = true;

      try {
        const response = await fetch(`/api/public-posts?page=${page}&limit=10`);
        if (!response.ok) {
          throw new Error('Failed to load public posts');
        }
        const data = await response.json();
        const images = data.images;
        hasMoreImages = data.hasMore; // Update the hasMore flag based on server response

        const imageList = document.getElementById('image-list');
        if (!imageList) {
          console.error('Image List container not found in the DOM.');
          return;
        }

        images.forEach(image => {
          const imageCard = document.createElement('div');
          imageCard.classList.add('image-card', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

          imageCard.innerHTML = `
            <span class="badge-public">Public</span>
            <img src="${image.imageUrl}" alt="Public Image" class="w-full h-auto rounded-lg" loading="lazy" />
          `;
          imageList.appendChild(imageCard);

          // Ensure the event listener is correctly attached to the image
          imageCard.querySelector('img').addEventListener('click', () => {
              console.log('Image clicked:', image.imageUrl); // Debugging line
              showFullSizeImage(image.imageUrl);
            });

        });

        page++; // Increment page number for the next load
      } catch (error) {
        console.error('Error loading public posts:', error);
        showToast('An error occurred while loading public posts.', 'error');
      } finally {
        isLoading = false;
      }
    }


    // Infinite scrolling logic
    window.addEventListener('scroll', () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading && hasMoreImages) {
        loadPublicPosts();
      }
    });

/*
// Function to load private/profile posts
   // Function to load private/profile posts
async function loadPrivatePosts() {
  try {
    const response = await fetch('/api/private-posts');
    if (!response.ok) {
      throw new Error('Failed to load profile posts');
    }
    const images = await response.json();
    const imageList = document.getElementById('image-list');
    if (!imageList) {
      console.error('Image List container not found in the DOM.');
      return;
    }
    imageList.innerHTML = ''; // Clear current images

    images.forEach(image => {
      const imageCard = document.createElement('div');
      imageCard.classList.add('relative', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

      // Add a badge to indicate if the image is private
      const badge = '<span class="badge-private">Private</span>';

      imageCard.innerHTML = `
        ${badge}
        <img src="${image.imageUrl}" alt="Private Image" class="w-full h-auto rounded-lg" loading="lazy" />
      `;
      imageList.appendChild(imageCard);

      // Add click event listener for full-size view
      imageCard.querySelector('img').addEventListener('click', () => {
        showFullSizeImage(image.imageUrl);
      });
    });
  } catch (error) {
    console.error('Error loading private posts:', error);
    showToast('An error occurred while loading your posts.', 'error');
  }
}

*/
   // Function to load private/profile posts
async function loadPrivatePosts() {
  try {
    const response = await fetch('/api/private-posts');
    if (!response.ok) {
      throw new Error('Failed to load profile posts');
    }
    const images = await response.json();
    const imageList = document.getElementById('image-list');
    if (!imageList) {
      console.error('Image List container not found in the DOM.');
      return;
    }
    imageList.innerHTML = ''; // Clear current images

    images.forEach(image => {
      const imageCard = document.createElement('div');
      imageCard.classList.add('image-card', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

      // Badge indicating public or private
      const badge = image.isPublic 
        ? '<span class="badge-public">Public</span>'
        : '<span class="badge-private">Private</span>';

      // Choose the appropriate icon and tooltip for the toggle button
      const toggleIcon = image.isPublic ? '<i class="fas fa-lock"></i>' : '<i class="fas fa-globe"></i>';
      const toggleTooltip = image.isPublic ? 'Make Private' : 'Make Public';

      // Create a container for all action buttons
      const actionButtons = `
        <div class="action-buttons absolute top-2 right-2 flex space-x-2">
          <a href="${image.imageUrl}" download class="download-button bg-green-600 text-white p-1 rounded shadow hover:bg-green-500" title="Download">
            <i class="fas fa-download"></i>
          </a>
          <button class="delete-button bg-white text-red-600 p-1 rounded shadow hover:bg-gray-100" data-id="${image.id}" title="Delete">
            <i class="fas fa-trash"></i>
          </button>
          <button class="toggle-visibility-button bg-blue-600 text-white p-1 rounded shadow hover:bg-blue-500" data-id="${image.id}" title="${toggleTooltip}">
            ${toggleIcon}
          </button>
        </div>
      `;

      imageCard.innerHTML = `
        ${badge}
        <img src="${image.imageUrl}" alt="${image.isPublic ? 'Public' : 'Private'} Image" class="w-full h-auto rounded-lg" loading="lazy" />
        ${actionButtons}
      `;

      imageList.appendChild(imageCard);

      // Add click event listener for full-size view
      imageCard.querySelector('img').addEventListener('click', () => {
        showFullSizeImage(image.imageUrl);
      });

      // Add click event listener for the delete button
      imageCard.querySelector('.delete-button').addEventListener('click', async (event) => {
        event.stopPropagation(); // Prevent triggering the full-size image view
        const imageId = event.target.closest('button').getAttribute('data-id');

        try {
          const response = await fetch(`/delete-private-image/${imageId}`, {
            method: 'DELETE',
          });

          if (response.ok) {
            showToast('Image deleted successfully!', 'success');
            imageCard.remove(); // Remove the card from the DOM
          } else {
            showToast('Failed to delete image', 'error');
          }
        } catch (error) {
          console.error('Error deleting image:', error);
          showToast('An error occurred while deleting the image', 'error');
        }
      });

      // Add click event listener for the toggle visibility button
      imageCard.querySelector('.toggle-visibility-button').addEventListener('click', async (event) => {
          event.stopPropagation(); // Prevent triggering the full-size image view
          const imageId = event.target.closest('button').getAttribute('data-id');

          try {
            const response = await fetch(`/update-image-visibility/${imageId}`, {
              method: 'PUT', 
              headers: { 'Content-Type': 'application/json' },
            });


            if (response.ok) {
              const data = await response.json();
              showToast('Image visibility updated!', 'success');
              // Optionally, refresh the view to reflect changes
              loadPrivatePosts();
            } else {
              showToast('Failed to update visibility', 'error');
            }
          } catch (error) {
            console.error('Error updating image visibility:', error);
            showToast('An error occurred while updating visibility', 'error');
          }
        });

        
        
    });
  } catch (error) {
    console.error('Error loading private posts:', error);
    showToast('An error occurred while loading your posts.', 'error');
  }
}




    // Function to show toast notifications
    function showToast(message, type = 'error') {
      const toastContainer = document.getElementById('toast-container');
      if (!toastContainer) {
        console.error('Toast container not found in the DOM.');
        return;
      }

      const toast = document.createElement('div');
      toast.classList.add('toast');

      if (type === 'success') {
        toast.classList.add('toast-success');
      } else {
        toast.classList.add('toast-error');
      }

      toast.textContent = message;
      toastContainer.appendChild(toast);

      // Remove the toast after 3 seconds with a fade-out animation
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.addEventListener('transitionend', () => {
          toast.remove();
        });
      }, 1000);
    }
      
      
    async function updateImageVisibility(imageId, isPublic) {
      try {
        const response = await fetch('/update-image-visibility', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ imageId, isPublic })
        });

        if (response.ok) {
          showToast(`Image visibility updated to ${isPublic ? 'public' : 'private'}!`, 'success');
        } else {
          showToast('Failed to update image visibility.', 'error');
        }
      } catch (error) {
        console.error('Error updating image visibility:', error);
        showToast('An error occurred while updating image visibility.', 'error');
      }
    }

      document.addEventListener('DOMContentLoaded', () => {
          
          

          
          const visibilityButton = document.getElementById('post-visibility-button');
          const visibilityIcon = document.getElementById('post-visibility-icon');
          const visibilityText = document.getElementById('post-visibility-text');
          const tooltip = document.getElementById('post-visibility-tooltip');

          visibilityButton.addEventListener('mouseover', () => {
            if (tooltip) {
              tooltip.classList.remove('hidden');
            }
          });

          visibilityButton.addEventListener('mouseout', () => {
            if (tooltip) {
              tooltip.classList.add('hidden');
            }
          });


          // Initial state: private (false)  
          updateVisibility();


          visibilityButton.addEventListener('click', () => {
            isPublic = !isPublic; // Toggle the state
            updateVisibility();
          });

          function updateVisibility() {
            if (isPublic) {
              // Public state
              visibilityIcon.innerHTML = `
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.522 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" />
              `;
              visibilityText.textContent = 'Post Public';
              if (tooltip) tooltip.textContent = 'Create in public'; // Check if tooltip exists
            } else {
              // Private state
              visibilityIcon.innerHTML = `
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7a10.048 10.048 0 012.13-3.962M9.879 9.879a3 3 0 104.243 4.243M15 12a3 3 0 01-6 0" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3l18 18" />
              `;
              visibilityText.textContent = 'Post Private';
              if (tooltip) tooltip.textContent = 'Create privately'; // Check if tooltip exists
            }
          }
    });


  </script>
</body>
</html>
