
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Character Encoding -->
    <meta charset="UTF-8">
    
    <!-- Viewport for Responsive Design -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    
  <title><%= title %></title>
  <% if (imageUrl) { %>
    <meta property="og:title" content="<%= title %>" />
    <meta property="og:description" content="<%= description %>" />
    <meta property="og:image" content="<%= imageUrl %>" />
    <meta property="og:url" content="<%= url %>" />
    <meta property="og:type" content="website" />
  <% } %>
    
    <meta name="title" content="Pixzor - AI Image and Video Creation Platform">
    <meta name="description" content="Create stunning AI-generated images and videos with advanced character consistency, face swap, and storytelling tools. Transform your creative vision into reality.">
    <meta name="keywords" content="AI image generation, AI video creation, character design, face swap, AI storytelling, generative AI, creative tools">
    
   
   
    <meta http-equiv="Content-Security-Policy" content="img-src 'self' https://lh3.googleusercontent.com;">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- Canonical Link -->
    <link rel="canonical" href="https://www.pixzor.com/">
    
  <!-- Tailwind CSS CDN -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.16/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <script src="https://js.stripe.com/v3/"></script>

  <style>
    /* Custom styles for the fixed prompt box */
    .fixed-prompt {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%; /* Ensure it takes most of the screen's width */
      max-width: 1200px; /* Cap it for larger screens */
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);      
      border-radius: 12px 12px 0 0;
      padding: 16px; /* Reduce padding slightly */
    }

    /* Add padding to the main content to prevent overlap with the fixed prompt box */
    .content-padding {
      padding-bottom: 300px; /* Adjust based on the prompt box height */
      padding-top: 60px; /* Adjust based on the height of your navbar */
    }

    /* Button styles */
      .custom-button {
          background-color: #4b5563; /* Gray color */
      color: white;
      transition: background-color 0.3s;
          
  width: auto; /* Let buttons adjust to content */
  padding: 8px 12px; /* Reduce padding for smaller screens */
  font-size: 0.875rem; /* Slightly smaller font for smaller screens */
}
    

    .custom-button:hover {
      background-color: #10b981; /* Green color on hover */
    }

    /* Modal backdrop */
    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.75); /* Semi-transparent black */
    }

    /* Logo Placeholder */
    .logo {
      width: 40px;
      height: 40px;
      background-color: #4b5563; /* Gray background */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      font-size: 1.2rem;
    }

    /* Fixed Generated Images Container */
    .generated-images-container {
      max-height: 80vh;
      overflow-y: auto;
    }

    /* Selected Toggle Button Style */
    .selected-toggle {
      background-color: #a1a1aa; /* Light Gray */
      color: white;
    }

    /* Make images take full width of the container */
    #image-list img {
      width: 100%;
      height: auto;
      object-fit: cover;
    }

    /* Adjust padding or margin as needed */
    .image-card {
      padding: 0;
    }

    nav {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.1); /* Light border */
      border-top: 4px solid #ffffff; /* White top for visibility */
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Badges */
    .badge-public {
      display: inline-block;
      background-color: green;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .badge-private {
      display: inline-block;
      background-color: red;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    /* Error Message Styling */
    #error-message {
      display: block;
      margin-top: 10px;
      font-size: 0.875rem;
      color: #f87171; /* Tailwind's red-400 */
    }

    /* Toast Notification Container */
    #toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
    }

    /* Toast Styles */
    .toast {
      background-color: #1f2937; /* Dark background */
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 10px;
      opacity: 0.95;
      transition: opacity 0.3s ease;
    }

    .toast-success {
      background-color: #10b981; /* Green */
    }

    .toast-error {
      background-color: #ef4444; /* Red */
    }

    .hidden {
      display: none;
    }
      
   
    #post-visibility-toggle:checked + .block {
      background-color: #10b981; 
    }
    #post-visibility-toggle:checked + .block + .dot {
      transform: translateX(4px); 
    }
      
   #post-visibility-button:hover + #post-visibility-tooltip {
      display: block;
    }
      
    .post-visibility-wrapper {
      position: relative; 
    }

    .custom-button {
      box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.2);
      transition: background-color 0.2s, box-shadow 0.2s;
    }
    .custom-button:hover {
      box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.3);
    }

    .image-card {
      position: relative;
      overflow: hidden; /* Ensures image scaling doesn't affect layout */
      border-radius: 12px; /* Matches other rounded elements */
    }

    .image-card img {
      cursor: pointer; /* Change cursor to a hand */
      transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Smooth hover effect */
    }

    .image-card:hover img {
      transform: scale(1.05); /* Slight zoom on hover */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); /* Add shadow */
    }
    .toggle-visibility-button {
      margin-left: 4px; /* Add some space between buttons */
      display: inline-block; /* Align with other buttons */
   }
    .bg-gray-100 {
      background-color: #f9f9f9; /* Light gray background */
    }
    .text-gray-900 {
      color: #111827; /* Dark text for contrast */
    }

   #close-comments-modal {
      font-size: 24px;
      font-weight: bold;
      line-height: 1;
      cursor: pointer;
      z-index: 10; /* Ensure it is above other elements */
      color: #555; /* Default color */
    }
/* Modal content */
#comments-modal > div {
  background-color: white;
  border-radius: 8px;
  
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
      
  #comments-modal {
    z-index: 1050; /* A value higher than the prompt box */
  }
      
 #comments-modal > div {
  width: 90%; /* Default width */
  height: 90%; /* Default height */
  display: flex;
  flex-direction: row;
  overflow: hidden;
}
#comments-modal .bg-white {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
      
.full-size-image {
  transition: transform 0.2s ease;
  cursor: zoom-in;      
}
      .fullscreen-modal {
  z-index: 1100; /* A value higher than #comments-modal */
}
/* Magnifying glass visibility */
#modal-image:hover + span {
  opacity: 1; /* Makes magnifying glass visible on hover */
}

/* Default state for the magnifying glass */
#modal-image + span {
  opacity: 0;
}

/* Text adjustments */
.text-black {
  color: black;
}

textarea#comment-input {
  color: black; /* Ensures visible text in comments input */
}
/* Magnifying glass visibility */
.group:hover .group-hover\:opacity-100 {
  opacity: 1;
}
.group-hover\:opacity-100 {
  opacity: 0;
}

/* Text shadow for magnifying glass */
.drop-shadow-md {
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7), -2px -2px 4px rgba(255, 255, 255, 0.7);
}

#modal-image {
  position: relative;
  padding: 10px;
  background: white; 
  border-radius: 8px;
}

#modal-prompt-container {
  height: 6rem; 
}
#comments-list {
  background-color: #ffffff; /* Optional: Set a light background */
  padding: 10px;
  border-radius: 5px;
}

#comments-list li {
  color: black; /* Ensures text is visible */
  font-size: 1rem;
  line-height: 1.5; /* Optional: Improves readability */
  margin-bottom: 8px; /* Adds spacing between comments */
}
#comments-list li {
  display: flex;
  align-items: flex-start;
  margin-bottom: 10px;
}

#comments-list img {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
}

#comments-list p {
  margin: 0;
}

#comments-list .font-bold {
  margin-bottom: 2px;
}


#copy-prompt {
  cursor: pointer; /* Make it clear the button is clickable */
  font-size: 1rem; /* Adjust size to match the title */
  margin-left: 8px; /* Add space between the title and the icon */
  background: none; /* Remove any default button styling */
  border: none; /* Remove border */
  padding: 0; /* Remove extra padding */
}
#copy-prompt:hover {
  color: #1f2937; /* Slight color change on hover */
}

#comments-modal {
  overflow-y: auto;  /* Allow vertical scrolling for the entire modal */
  -webkit-overflow-scrolling: touch;  /* Smooth scrolling on iOS */
}

#comments-modal > div {
  max-height: 90vh;  /* Limit height to 90% of viewport height */
  overflow-y: auto;  /* Enable scrolling for the modal content */
}

/* Ensure the comments list can scroll independently */
#comments-list {
  max-height: 50vh;  /* Limit comments list height */
  
}


@media (max-width: 768px) { 
  /* Ensure the modal container doesn't scroll the background */
    body.modal-open {
      overflow: hidden;
    }

    /* Make the modal content scrollable */
    #comments-modal {
      overflow: auto;
      max-height: 100vh; /* Limit modal height to the viewport */
    }

    #comments-modal .flex-grow.overflow-hidden {
      overflow-y: auto; /* Enable vertical scrolling for the comments section */
      max-height: 60vh; /* Adjust based on desired modal height */
    }
    
    
  #comments-modal > div {
    flex-direction: column; 
    height: auto;
  }
  #comments-modal .bg-gray-100 {
    width: 100%; 
  }
  #comments-modal .p-6 {
    width: 100%; 
  }
}

      
#prompt-input { 
  box-sizing: border-box;
  padding: 8px;
  font-size: 1rem;
  resize: none;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #1a1a1a;
  color: white;
}
  
      
@media (max-width: 640px) {
  body {
    font-size: 14px;
  }

  .content-padding {
    padding-bottom: 200px;
    padding-top: 50px;
  }

  .image-card {
    margin: 5px;
  }

  .custom-button {
    font-size: 0.75rem;
    padding: 6px 10px;
  }

  button, 
  .custom-button, 
  .toggle-visibility-button {
    min-height: 48px; /* Improve touch targets */
    min-width: 48px;
  }

  .custom-button:active {
    background-color: #10b981; 
    transform: scale(0.98);
  }

  .fixed-prompt {
    width: 100%; 
    left: 0;
    transform: none;
    box-sizing: border-box;
    padding: 8px;    
    overflow-y: auto;
  }

  #prompt-input {
    font-size: 0.875rem;
    padding: 8px;
    width: 100%;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 6px;
  }

  .fixed-prompt .flex-col {
    gap: 0.5rem; /* Reduce space between items */
  }

  .image-card:hover img {
    transform: none; /* Disable hover effects */
  }
}

</style>
</head>
<body class="bg-gray-900 text-white">
    
    

    
  <!-- Navbar -->
  <nav class="bg-gray-800 shadow-md fixed top-0 left-0 right-0 z-50">
  <div class="container mx-auto px-2 py-2 flex flex-wrap justify-between items-center">
    <!-- Logo -->
    <div id="logo" class="flex items-center space-x-2 cursor-pointer">
      <img src="/images/logo.png" alt="Pixzor Logo" class="w-6 h-6 sm:w-8 sm:h-7">
      <span class="text-lg sm:text-xl font-bold">Pixzor</span>
    </div>

    <!-- Mobile-friendly button layout -->
    <div class="flex items-center space-x-2 sm:space-x-4">
      <button id="tokens-button" class="flex items-center bg-gray-700 hover:bg-yellow-600 px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 text-yellow-400 mr-1 sm:mr-2" viewBox="0 0 20 20" fill="currentColor">
          <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
          <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM10 18a8 8 0 100-16 8 8 0 000 16z" clip-rule="evenodd" />
        </svg>
        <span id="token-count" class="text-yellow-400">Tokens</span>          
      </button>

      <button id="google-auth-button" class="flex items-center bg-gray-700 hover:bg-green-600 px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
        <img src="https://img.icons8.com/ios-filled/24/ffffff/google-logo.png" alt="Google" class="w-4 h-4 sm:w-6 sm:h-6 mr-1 sm:mr-2" crossorigin="anonymous" referrerPolicy="no-referrer" />
        <span>Login</span>
      </button>
    </div>
  </div>
</nav>

  
  <!-- Fixed Container for Toggle Buttons -->
<div class="fixed left-0 right-0 z-40" style="top: 56px;"> <!-- Adjust top value as needed -->
  <div class="container mx-auto py-2 flex justify-center">
    <!-- Buttons without a distinct background layer -->
    <button id="public-toggle" class="custom-button bg-transparent text-white px-4 rounded-l-lg text-sm selected-toggle hover:bg-gray-700" style="height: 32px; border: 1px solid rgba(255, 255, 255, 0.3);">        
      Public Posts
    </button>
    <button id="profile-toggle" class="custom-button bg-transparent text-white px-4 rounded-r-lg text-sm hover:bg-gray-700" style="height: 32px; border: 1px solid rgba(255, 255, 255, 0.3);">
      Profile Posts
    </button>
  </div>
</div>

<!-- Main Container -->
<div class="container mx-auto py-20 content-padding">
  <!-- Error Message -->
  <div id="error-message" class="text-red-500 text-center mb-4"></div>

  <!-- User Profile Container -->
  <div id="profile-container">
    <!-- User Profile Header -->
    <div class="flex items-center space-x-4 mb-8">
      <img id="profile-avatar" src="" alt="User Avatar" class="w-16 h-16 rounded-full hidden"  referrerPolicy="no-referrer" >
      <h1 id="profile-username" class="text-2xl font-bold"></h1>
    </div>

    <!-- Public Images Grid -->
    <div id="image-list" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-4">
      <!-- Public images will be dynamically added here -->
    </div>
  </div>
</div>


<!-- Fixed Prompt and Buttons at the Bottom -->
<div class="fixed-prompt bg-gray-800 rounded-t-lg shadow-md">
  <div class="container mx-auto">
      
    <!-- Prompt Input --> 
    <div class="flex flex-col md:flex-row items-stretch md:space-x-4"> <!-- Changed items-center to items-stretch -->
      <div class="mb-4 md:mb-0 flex-grow min-w-0">
          
        <textarea
  id="prompt-input"
  class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white border border-gray-300 resize-y"
  rows="2"
  placeholder="Enter your prompt"
  aria-label="Prompt Input"
></textarea>

      </div>
    </div>



    <!-- Prompt Options and Generate Button -->
    <div class="flex flex-col md:flex-row justify-between mt-4 space-y-2 md:space-y-0">
      <div class="flex space-x-2">
          
        <button id="options-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Options</button>
        
       
        <button id="enhance-prompt-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Enhance Prompt</button>
          
          
        <button id="setup-character-button" class="custom-button font-medium px-4 rounded-lg text-sm" style="height: 32px;">Add Character</button>
        <div class="flex justify-center mb-4">
          <select id="character-select" class="w-full max-w-xs bg-gray-700 rounded-lg py-1 px-0 text-white" aria-label="Select Character">
            <option value="" disabled selected>Select Character</option>
            
          </select>
        </div> 
          
          
      </div> 
       
        
      
    <!-- Post Visibility Toggle and Generate Button -->
<div class="flex items-center space-x-2">
  <!-- Visibility Text -->
  <span id="post-visibility-text" class="ml-2 text-white">Post Public</span>
  
    
  <!-- Post Visibility Button and Tooltip Wrapper -->
  <div class="relative flex items-center"> <!-- Added "relative" to the container -->
    <button id="post-visibility-button" class="bg-gray-700 text-white px-2 py-2 rounded-lg hover:bg-gray-600 focus:outline-none">
      <!-- Eye Icon -->
      <svg id="post-visibility-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <!-- Initial "eye" icon -->
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.522 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" />
      </svg>
    </button>

    <!-- Tooltip Element -->
    <span id="post-visibility-tooltip" class="absolute bottom-12 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 whitespace-nowrap hidden">
      Create in public
    </span>
  </div>

  <!-- Generate Image Button -->
  <button id="generate-button" class="bg-green-700 hover:bg-green-600 text-white font-medium px-4 rounded-lg text-sm" style="height: 32px;">Generate Image</button>
</div>
        
    </div>
  </div>
</div>

  
<!-- Buy Tokens Modal -->
<div id="buy-tokens-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-100 text-gray-900 rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="close-buy-tokens-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">
        &times;
      </button>
      <h2 class="text-xl font-bold mb-4">Buy Tokens</h2>
      <form id="buy-tokens-form">
        <label for="token-bundle" class="block mb-2">Select a Token Bundle:</label>
        <select id="token-bundle" class="w-full border rounded-lg p-2 mb-4">
          <option value="500" data-price="5.00">500 Tokens - $5.00</option>
          <option value="1200" data-price="10.00">1200 Tokens - $10.00</option>
          <option value="3000" data-price="20.00">3000 Tokens - $20.00</option>
          <option value="5000" data-price="30.00">5000 Tokens - $30.00</option>
        </select>
        <button type="submit" class="w-full bg-green-600 text-white py-2 rounded-lg hover:bg-green-500">
          Purchase Tokens
        </button>
      </form>
    </div>
  </div>
</div>



<!-- Options Modal -->
<div id="options-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="options-modal-title">
  <div class="flex items-center justify-center min-h-screen px-4">
    <div class="bg-gray-200 border-2 border-white rounded-lg shadow-lg w-full max-w-md p-6 relative">
      <button id="close-options-modal" class="absolute top-2 right-2 text-gray-600 hover:text-gray-800" aria-label="Close">&times;</button>
      <h2 id="options-modal-title" class="text-xl font-bold mb-4 text-gray-900">Options</h2>
                         
          <div class="mb-4">
            <label for="style-select-modal" class="block font-medium mb-1">Select Style</label>
            <select id="style-select-modal" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white">
              <option value="" disabled selected>Choose a style</option>
              <option value="pixar">Photo</option>    
              <option value="pixar">Pixar</option>
              <option value="anime">Anime</option>
              <option value="cartoon">Cartoon</option>             
            </select>
          </div>
                 
      <form id="options-form">           
  <!-- Set Variables -->
  <div class="mb-4">
    <label for="width-modal" class="block font-medium mb-1 text-gray-900">Width</label>
    <input type="number" id="width-modal" value="800" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Width (e.g., 800)">
    <label for="height-modal" class="block font-medium mb-1 text-gray-900">Height</label>
    <input type="number" id="height-modal" value="600" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Height (e.g., 600)">
    <label for="guidance-scale-modal" class="block font-medium mb-1 text-gray-900">Guidance Scale</label>
    <input type="number" step="0.1" id="guidance-scale-modal" value="3.5" class="w-full bg-gray-300 rounded-lg py-2 px-3 mb-2 text-gray-900 placeholder-gray-600" placeholder="Guidance Scale">
    <label for="inference-steps-modal" class="block font-medium mb-1 text-gray-900">Inference Steps</label>
    <input type="number" id="inference-steps-modal" value="4" class="w-full bg-gray-300 rounded-lg py-2 px-3 text-gray-900 placeholder-gray-600" placeholder="Inference Steps">
  </div>

  <div class="flex justify-end">
    <button type="submit" class="custom-button font-medium py-2 px-4 bg-gray-700 text-white rounded-lg hover:bg-gray-600">Save Options</button>
  </div>
</form>

    </div>
  </div>
</div>
    
    

  <!-- Setup Character Modal -->
<div id="setup-character-modal" class="fixed z-50 inset-0 overflow-y-auto hidden" role="dialog" aria-modal="true" aria-labelledby="setup-character-modal-title">
 
    <div class="flex items-center justify-center min-h-screen px-4">
      <div class="bg-gray-800 rounded-lg shadow-lg w-full max-w-md p-6 relative">
        <button id="close-setup-character-modal" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600" aria-label="Close">&times;</button>
        <h2 id="setup-character-modal-title" class="text-xl font-bold mb-4">Setup Character</h2>
        <form id="setup-character-form">
          <!-- Character Name -->
          <div class="mb-4">
            <label for="character-name" class="block font-medium mb-1">Character Name</label>
            <input type="text" id="character-name" name="character-name" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" required>
          </div>
          <!-- Character Description -->
          <div class="mb-4">
            <label for="character-description" class="block font-medium mb-1">Description</label>
            <textarea id="character-description" name="character-description" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white" rows="4" placeholder="Describe your character"></textarea>
          </div>
          <!-- Upload Face -->
          <div class="mb-4">
            <label for="face-upload-character" class="block font-medium mb-1">Upload Face</label>
            <input type="file" id="face-upload-character" class="w-full bg-gray-700 rounded-lg py-2 px-3 text-white">
          </div>
          <div class="flex justify-end">
            <button type="submit" class="custom-button font-medium py-2 px-4 rounded-lg">Save Character</button>
          </div>
        </form>
      </div>
    </div>
  </div>
    
 <!-- Updated Comments Modal -->
<!-- Updated Comments Modal -->
<div id="comments-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50">
  <div class="bg-white rounded-lg shadow-lg flex flex-col md:flex-row relative w-11/12 md:w-4/5 max-h-screen overflow-y-auto">
    <!-- Close Button -->
 <button id="close-comments-modal" class="absolute top-2 right-2 bg-gray-400 text-white hover:bg-gray-300 rounded-full p-1 text-2xl z-30" aria-label="Close Comments Modal">
  &times;
</button>


    <!-- Left Section: Image -->
    <div class="md:w-2/3 bg-gray-100 flex items-start justify-center p-4 relative">
      <!-- Fullscreen Icon -->
      <button id="fullscreen-icon" class="absolute top-2 left-2 bg-black text-white p-1 rounded-full text-sm z-20" aria-label="Fullscreen Image">
        <i class="fas fa-expand"></i>
      </button>
      <img id="modal-image" src="" alt="Full Image" class="w-full h-auto rounded-lg object-contain">
    </div>

    <!-- Right Section: Details and Comments -->
    <div class="md:w-1/3 p-6 flex flex-col space-y-4">
      <!-- Prompt -->
      <div class="flex flex-col">
        <h3 class="text-lg font-bold text-black mb-2 flex items-center">
          Prompt
          <button id="copy-prompt" class="ml-2 text-gray-500 hover:text-gray-700" title="Copy Prompt" aria-label="Copy Prompt">
            <i class="fas fa-copy"></i>
          </button>
        </h3>
        <div id="modal-prompt-container" class="border p-3 rounded max-h-24 overflow-y-auto bg-gray-50 relative">
          <p id="modal-prompt" class="text-gray-600 pr-8"></p>
        </div>
      </div>

      <!-- User Profile -->
      <div>
        <h3 class="text-lg font-bold text-black">Created By <a id="modal-user-profile" href="#" class="text-blue-500 hover:underline"></a></h3>    
      </div>

      <!-- Action Buttons with Icons and Tooltips -->
      <div class="flex flex-wrap gap-2">
        <div class="relative group">
          <a id="download-button" href="#" class="bg-green-600 text-white p-2 rounded flex items-center" download>
            <i class="fas fa-download"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Download</span>
        </div>
          
          
        <div class="relative group">
          <a id="create-button" href="#" class="btn bg-purple-600 text-white p-2 rounded flex items-center" aria-label="Create Similar">
            <i class="fas fa-pencil-alt"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Create Similar</span>
        </div>
          
          
          
        <div class="relative group">
          <a id="share-facebook" href="#" target="_blank" class="bg-blue-600 text-white p-2 rounded flex items-center" aria-label="Share on Facebook">
            <i class="fab fa-facebook-f"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Facebook</span>
        </div>
          
          
          
        <div class="relative group">
          <a id="share-twitter" href="#" target="_blank" class="bg-blue-400 text-white p-2 rounded flex items-center" aria-label="Share on Twitter">
            <i class="fab fa-twitter"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Twitter</span>
        </div>
        <div class="relative group">
          <a id="share-pinterest" href="#" target="_blank" class="bg-red-600 text-white p-2 rounded flex items-center" aria-label="Share on Pinterest">
            <i class="fab fa-pinterest-p"></i>
          </a>
          <span class="absolute bottom-full left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs rounded px-2 py-1 opacity-0 group-hover:opacity-100 transition-opacity">Pinterest</span>
        </div>
      </div>

      <!-- Comments Section -->
      <div class="flex flex-col flex-grow overflow-hidden">
        <h3 class="text-lg font-bold text-black mb-2">Comments</h3>
        <div class="flex-grow overflow-y-auto mb-4">
          <ul id="comments-list" class="space-y-2"></ul>
        </div>
        
        <!-- Comment Input at the Bottom -->
        <div class="mt-auto">
          <textarea id="comment-input" placeholder="Write a comment..." class="w-full p-2 border rounded text-black mb-2" aria-label="Write a comment"></textarea>
          <button id="post-comment" class="w-full bg-green-600 text-white px-4 py-2 rounded" aria-label="Post Comment">Post Comment</button>
        </div>
      </div>
    </div>
  </div>
</div>



  <!-- Toast Notification Container -->
  <div id="toast-container" class="fixed top-20 right-20 z-50"></div>

  <!-- JavaScript -->
  <script>
    // script.js
    let isPublic = false;

    document.addEventListener('DOMContentLoaded', () => {
      // Fetch user data on page load
      fetchUserData();

      // Initialize character dropdown
      populateCharacterDropdown();

      // Load public posts by default
      loadPublicPosts();

      // Set up event listeners
      setupEventListeners();
    });

      
    
   


async function loadUserProfile(userId) {
  try {
    // Close comments modal if it is open
    const commentsModal = document.getElementById('comments-modal');
    if (!commentsModal.classList.contains('hidden')) {
      commentsModal.classList.add('hidden'); // Hide the modal
      history.pushState(null, '', window.location.origin);    
    }

    const response = await fetch(`/api/user-profile/${userId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch user profile.');
    }

    const { user, publicImages } = await response.json();

    // Render user info
    const profileUsername = document.getElementById('profile-username');
    const profileAvatar = document.getElementById('profile-avatar');
    profileUsername.textContent = user.username;
    profileAvatar.src = user.photo || '/default-avatar.png'; // Fallback to default avatar
    profileAvatar.classList.remove('hidden');

    // Render public images
    const imageList = document.getElementById('image-list');
    imageList.innerHTML = ''; // Clear existing images

    publicImages.forEach(image => {
      const imageCard = document.createElement('div');
      imageCard.classList.add('image-card', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

      imageCard.innerHTML = `
        <img src="${image.thumbnailUrl}" alt="Public Image" class="w-full h-auto rounded-lg" />
        <p class="text-sm text-gray-400 mt-2">${image.prompt}</p>
      `;

      imageList.appendChild(imageCard);

      // Optional: Add click listener for full-size image view
      imageCard.querySelector('img').addEventListener('click', () => {
        openCommentsModal(image.id, image.imageUrl, 'public');
      });
    });
  } catch (error) {
    console.error('Error loading user profile:', error);
    showToast('Failed to load user profile.', 'error');
  }
}

      
      
   function updateShareLinks(imageId, source) {
      const baseUrl = window.location.origin;
      const modalUrl = `${baseUrl}/?image=${imageId}&source=${source}`;
      const shareText = 'Check out this amazing AI-generated image!';

      document.getElementById('share-facebook').href = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(modalUrl)}`;
      document.getElementById('share-twitter').href = `https://twitter.com/intent/tweet?url=${encodeURIComponent(modalUrl)}&text=${encodeURIComponent(shareText)}`;
      document.getElementById('share-pinterest').href = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(modalUrl)}&media=${encodeURIComponent(modalUrl)}&description=${encodeURIComponent(shareText)}`;
    }



    function updateBrowserHistory(imageId, source) {
      history.pushState(null, '', `/?image=${imageId}&source=${source}`);
    }
      
    function setupComments(imageId) {
      
      // Use imageId to fetch and post comments
      // Update the global or modal-scoped variable to keep track of imageId
      window.currentImageId = imageId;

      // Fetch comments
      loadComments(imageId);
    }  


    function openCommentsModal(imageId, imageUrl, source) {


      const modalImage = document.getElementById('modal-image');
      const modalPrompt = document.getElementById('modal-prompt');
      const modalUserProfile = document.getElementById('modal-user-profile');
      const downloadButton = document.getElementById('download-button');

      modalImage.src = imageUrl;
      downloadButton.href = imageUrl;
      downloadButton.download = `image-${imageId}.jpg`;

      fetch(`/api/image-details/${imageId}`)
        .then(response => response.json())
        .then(data => {
          modalPrompt.textContent = data.prompt || 'No prompt available.';
          modalUserProfile.textContent = data.username;
          modalUserProfile.href = `/user-profile/${data.userId}`;
          modalUserProfile.dataset.userId = data.userId; // Using dataset
        })
        .catch(error => {
          console.error('Error fetching image details:', error);
          showToast('Failed to load image details.', 'error');
        });

      updateShareLinks(imageId, source);
      updateBrowserHistory(imageId, source);
        
      // Update the imageId to be the personalImageId if necessary
      if (source === 'public') {
        // Fetch the personalImageId from the public image
        fetch(`/api/public-image-details/${imageId}`)
          .then(response => response.json())
          .then(data => {
            const personalImageId = data.personalImageId;
            
            // Use personalImageId for comments
            setupComments(personalImageId);
          })
          .catch(error => {
            console.error('Error fetching image details:', error);
            showToast('Failed to load image details.', 'error');
          });
      } else {
        // For personal images, use the imageId directly          
        setupComments(imageId);
      }    

      document.getElementById('comments-modal').classList.remove('hidden');
        
    }

      
      
      
    // Function to fetch user data
    async function fetchUserData() {
      try {
        const response = await fetch('/user-data');
        const data = await response.json();

        const tokenCountElement = document.getElementById('token-count');
        const googleAuthButton = document.getElementById('google-auth-button');

        if (data.loggedIn) {
          // Update the token count
          tokenCountElement.textContent = `Tokens: ${data.tokens}`;

          // Update the Google Auth button to show user info
          googleAuthButton.innerHTML = `
            <img src="${data.photo}" alt="Profile" class="mr-2 w-6 h-6 rounded-full" />
            <span>${data.username}</span>
          `;
          googleAuthButton.classList.remove('bg-gray-700');
          googleAuthButton.classList.add('bg-green-600');

          // Enable the generate button
          document.getElementById('generate-button').disabled = false;
        } else {
          // User is not logged in
          tokenCountElement.textContent = `Tokens: 0`;
          googleAuthButton.innerHTML = 'Login with Google';
          googleAuthButton.classList.remove('bg-green-600');
          googleAuthButton.classList.add('bg-gray-700');

          // Disable the generate button
          document.getElementById('generate-button').disabled = true;
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
        showToast('An error occurred while fetching user data.', 'error');
      }
    }

    // Function to set up all event listeners
    function setupEventListeners() {
          
          const modalImage = document.getElementById('modal-image');
        
          document.getElementById("enhance-prompt-button").addEventListener("click", async () => {
              const promptInput = document.getElementById("prompt-input");
              const prompt = promptInput.value.trim();

              // Check if the prompt is empty
              if (!prompt) {
                showToast("Please enter a prompt!", "error");
                return;
              }

              try {
                // Send the prompt to the server
                const response = await fetch("/enhance-prompt", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({ prompt })
                });

                if (!response.ok) {
                  throw new Error("Failed to enhance the prompt. Please try again.");
                }

                const data = await response.json();
                promptInput.value = data.result; // Update the input area with the enhanced prompt
                showToast("Prompt enhanced successfully!", "success");
              } catch (error) {
                console.error(error);
                showToast(error.message, "error");
              }
            });
        
        
          document.getElementById('create-button').addEventListener('click', async () => {
          try {
            // Check authentication status
            const response = await fetch('/check-auth', { method: 'GET' });
            const data = await response.json();

            if (!data.isAuthenticated) {
              // Show a toast notification if the user is not logged in
              showToast('Please log in first to create an image.', 'error');
              return; // Prevent further actions
            }

            // Proceed with copying the prompt if the user is authenticated
            const promptText = document.getElementById('modal-prompt').textContent.trim();
            const mainPromptInput = document.getElementById('prompt-input');

            if (mainPromptInput && promptText) {
              mainPromptInput.value = promptText; // Copy the prompt text to the main input
              document.getElementById('comments-modal').classList.add('hidden'); // Close the modal
              showToast('Prompt copied! Ready to create similar.', 'success'); // Optional: Provide feedback
            }
          } catch (error) {
            console.error('Error checking authentication:', error);
            showToast('An error occurred. Please try again.', 'error');
          }
        });


        
          document.getElementById('copy-prompt').addEventListener('click', () => {
              const promptText = document.getElementById('modal-prompt').textContent.trim();

              // Check if there's text to copy
              if (promptText) {
                navigator.clipboard.writeText(promptText).then(() => {
                  // Show success toast
                  showToast('Prompt copied to clipboard!');
                }).catch(err => {
                  // Show error toast if copying fails
                  showToast('Failed to copy prompt', 'error');
                  console.error('Copy failed:', err);
                });
              } else {
                showToast('No prompt to copy', 'error');
              }
            });

          modalImage.addEventListener('click', () => {
            const fullScreenModal = document.createElement('div');
            fullScreenModal.classList.add(
              'fixed',
              'inset-0',
              'bg-black',
              'bg-opacity-90',
              'flex',
              'justify-center',
              'items-center',
              'fullscreen-modal'
            );
            fullScreenModal.innerHTML = `
              <div class="relative">
                <img src="${modalImage.src}" alt="Full Image" class="max-w-full max-h-screen rounded-lg">
                <button class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full" id="close-fullscreen-modal">&times;</button>
              </div>
            `;

            // Append fullscreen modal to the document body
            document.body.appendChild(fullScreenModal);

            // Add event listener to close the modal
            const closeButton = fullScreenModal.querySelector('#close-fullscreen-modal');
            closeButton.addEventListener('click', () => {
              fullScreenModal.remove();
            });

            // Close the modal when clicking outside the image
            fullScreenModal.addEventListener('click', (e) => {
              if (e.target === fullScreenModal) {
                fullScreenModal.remove();
              }
            });
          });
        
        


          // Handle Generate Image Button Click
          document.getElementById('generate-button').addEventListener('click', async () => {
            const prompt = document.getElementById('prompt-input').value.trim();
            const characterIndex = document.getElementById('character-select').value;
            const options = JSON.parse(localStorage.getItem('options')) || {};
            const dimensions = {
              width: parseInt(options.width) || 800,
              height: parseInt(options.height) || 600
            };
            const style = options.style || '';

            // Clear previous error message
            document.getElementById('error-message').textContent = '';

            // Fetch user data to check authentication
            let userData;
            try {
              const response = await fetch('/user-data');
              userData = await response.json();
            } catch (error) {
              console.error('Error fetching user data:', error);
              showToast('An error occurred. Please try again.', 'error');
              return;
            }

            if (!userData.loggedIn) {
              // Prompt user to log in
              showToast('Please log in to generate images.', 'error');
              return;
            }

            // Check Token Availability
            let currentTokens = parseInt(userData.tokens) || 0;
            if (currentTokens <= 0) {
              showToast('You have no tokens left. Please buy more tokens to generate images.', 'error');
              return;
            }

            if (!prompt) {
              showToast('Please enter a prompt.', 'error');
              return;
            }

            // Add Placeholder
            const imageList = document.getElementById('image-list');
            if (!imageList) {
              console.error('Image List container not found in the DOM.');
              showToast('An error occurred. Please try again.', 'error');
              return;
            }

            // Create a container for both placeholder and image
            const imageContainer = document.createElement('div');
            imageContainer.classList.add('relative', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

            // Style the placeholder to be slightly lighter
            imageContainer.style.backgroundColor = '#2d2d2d'; // Adjust as needed

            // Use Flexbox to center the spinner
            imageContainer.innerHTML = `
              <div class="flex justify-center items-center h-full">
                <div class="spinner"></div>
              </div>
            `;

            imageList.prepend(imageContainer);          

            let finalPrompt = prompt;

            // Append character description if a character is selected
            if (characterIndex !== "") {
              const characters = JSON.parse(localStorage.getItem('characters')) || [];
              const selectedCharacter = characters[characterIndex];
              if (selectedCharacter) {
                finalPrompt = `${selectedCharacter.description}. ${prompt}`;
              }
            }

            // Append style if selected
            if (style) {
              finalPrompt = `${finalPrompt} Style: ${style}.`;
            }

            try {
              // Show loading state
              const generateButton = document.getElementById('generate-button');
              generateButton.textContent = 'Generating...';
              generateButton.disabled = true;              

              
              // Send data to backend for image generation
              const response = await fetch('/generate-image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  prompt: finalPrompt,
                  isPublic: isPublic,
                  width: dimensions.width,
                  height: dimensions.height,
                  guidanceScale: parseFloat(options.guidanceScale) || 3.5,
                  inferenceSteps: parseInt(options.inferenceSteps) || 4
                })
              });

              const data = await response.json();
              if (response.ok && data.imageUrl) {
                // Create image element
                const imgElement = document.createElement('img');
                imgElement.src = data.imageUrl;
                imgElement.alt = 'Generated Image';
                imgElement.classList.add('w-full', 'h-auto', 'object-cover', 'rounded-lg');

                // Hide image initially until it's fully loaded
                imgElement.style.display = 'none';
                imageContainer.appendChild(imgElement);

                // Listen for image load event
                imgElement.addEventListener('load', () => {
                  imgElement.style.display = 'block'; // Show image
                  // Remove spinner
                  const spinner = imageContainer.querySelector('.spinner');
                  if (spinner) {
                    spinner.remove();
                  }

                  // Update Tokens Count in Navbar
                  updateTokenCount(-data.tokensUsed); // Subtract tokens

                  // Switch to Profile Posts after a short delay to ensure the image is visible
                  setTimeout(() => {
                    document.getElementById('profile-toggle').click();
                  }, 500);

                  showToast('Image generated successfully!', 'success');
                });

                // Handle image load error
                imgElement.addEventListener('error', () => {
                  showToast('Failed to load image.', 'error');
                  imageList.removeChild(imageContainer); // Remove the placeholder on error
                });
              } else {
                // Handle error message from backend
                showToast(data.error || 'Failed to generate image.', 'error');
                imageList.removeChild(imageContainer); // Remove the placeholder on failure
              }
            } catch (error) {
              console.error('Error generating image:', error);
              showToast('An error occurred while generating the image.', 'error');
              imageList.removeChild(imageContainer); // Remove the placeholder on error
            } finally {
              // Reset button state
              const generateButton = document.getElementById('generate-button');
              generateButton.textContent = 'Generate Image';
              generateButton.disabled = false;
            }
          });
        
        
        
      // Handle Google Authentication Button Click
      const googleAuthButton = document.getElementById('google-auth-button');
      if (googleAuthButton) {
        googleAuthButton.addEventListener('click', () => {
          // Redirect to Google OAuth endpoint
          window.location.href = '/auth/google';
        });
      }

      // Modal Elements
      const modals = {
        'options-modal': document.getElementById('options-modal'),
        'setup-character-modal': document.getElementById('setup-character-modal'),
        'buy-tokens-modal': document.getElementById('buy-tokens-modal'),
      };

      // Function to open a modal
      function openModal(modalId) {
        if (modals[modalId]) {
          modals[modalId].classList.remove('hidden');
          document.body.classList.add('modal-open');    
          document.body.classList.add('overflow-hidden'); // Prevent background scrolling
        }
      }

      // Function to close a modal
      function closeModal(modalId) {
        if (modals[modalId]) {
          modals[modalId].classList.add('hidden');
          document.body.classList.remove('modal-open');       
          document.body.classList.remove('overflow-hidden');
        }
      }

      // Event Listeners for Opening Modals
      document.getElementById('options-button').addEventListener('click', () => openModal('options-modal'));
      //document.getElementById('setup-character-button').addEventListener('click', () => openModal('setup-character-modal'));
      //document.getElementById('tokens-button').addEventListener('click', () => openModal('buy-tokens-modal'));

      document.getElementById('tokens-button').addEventListener('click', async () => {
          try {
            // Fetch user data to check if the user is logged in
            const response = await fetch('/user-data');
            const userData = await response.json();

            if (!userData.loggedIn) {
              // If user is not logged in, show a message instead of the token modal
              showToast('Please log in to buy tokens.', 'error');
              return;
            }

            // Show the Buy Tokens Modal if the user is logged in
            document.getElementById('buy-tokens-modal').classList.remove('hidden');
          } catch (error) {
            console.error('Error checking user login status:', error);
            showToast('An error occurred. Please try again.', 'error');
          }
        });


      document.getElementById('buy-tokens-form').addEventListener('submit', async (e) => {
          e.preventDefault();
          const bundle = document.getElementById('token-bundle');
          const tokens = bundle.value;
          const price = bundle.options[bundle.selectedIndex].dataset.price;

          try {
            const response = await fetch('/create-checkout-session', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tokens, price }),
            });

            const session = await response.json();
            if (response.ok) {
              // Replace with your actual publishable key
              const stripe = Stripe('pk_live_51QNNomGgZQx5JKvIyEzYuHbqZRdugWTVlseapCphcAL3gYdrXfSIN8R6toeaReScar1gFyxRODHv0XG1cf54xUsM00zJcyWw8j');
              await stripe.redirectToCheckout({ sessionId: session.id });
            } else {
              alert('Failed to initiate payment');
            }
          } catch (error) {
            console.error('Error:', error);
            alert('An error occurred while processing your payment');
          }
        });


        
        
        
      // Event Listeners for Closing Modals
      document.querySelectorAll('[id^="close-"]').forEach(button => {
        button.addEventListener('click', () => {
          const modalId = button.id.replace('close-', '');
          closeModal(modalId);
        });
      });

      // Close any open modals when clicking outside the modal content
      Object.keys(modals).forEach(modalId => {
        const modal = modals[modalId];
        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              closeModal(modalId);
            }
          });
        }
      });

      // Handle Options Form Submission
      document.getElementById('options-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const style = document.getElementById('style-select-modal').value;
        const width = document.getElementById('width-modal').value;
        const height = document.getElementById('height-modal').value;
        const guidanceScale = document.getElementById('guidance-scale-modal').value;
        const inferenceSteps = document.getElementById('inference-steps-modal').value;

        // Validate inputs
        if (!width || !height || !guidanceScale || !inferenceSteps) {
          showToast('Please fill in all option fields.', 'error');
          return;
        }

        // Save options to LocalStorage
        const options = {
          style,
          width,
          height,
          guidanceScale,
          inferenceSteps,
        };

        localStorage.setItem('options', JSON.stringify(options));

        // Close the Options Modal
        closeModal('options-modal');

        showToast('Options saved successfully!', 'success');
      });

      // Handle Setup Character Form Submission
      document.getElementById('setup-character-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const name = document.getElementById('character-name').value.trim();
        const description = document.getElementById('character-description').value.trim();
        const faceUpload = document.getElementById('face-upload-character').files[0];

        if (name && description) {
          // Save to LocalStorage
          let characters = JSON.parse(localStorage.getItem('characters')) || [];
          characters.push({ name, description, faceUpload: faceUpload ? faceUpload.name : null });
          localStorage.setItem('characters', JSON.stringify(characters));

          // Update Character Dropdown
          populateCharacterDropdown();

          // Clear the form
          document.getElementById('setup-character-form').reset();

          // Close Modal
          closeModal('setup-character-modal');

          showToast('Character added successfully!', 'success');
        } else {
          showToast('Please fill in all fields.', 'error');
        }
      });

        /*
      // Handle Enhance Prompt Button Click
      document.getElementById('enhance-prompt-button').addEventListener('click', async () => {
        const prompt = document.getElementById('prompt-input').value.trim();
        if (!prompt) {
          showToast('Please enter a prompt to enhance.', 'error');
          return;
        }

        try {
          // Show loading state
          const enhanceButton = document.getElementById('enhance-prompt-button');
          enhanceButton.textContent = 'Enhancing...';
          enhanceButton.disabled = true;

          // Send prompt to backend for enhancement
          const response = await fetch('/api/enhance-prompt', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
          });

          const data = await response.json();
          if (data.enhancedPrompt) {
            document.getElementById('prompt-input').value = data.enhancedPrompt;
            showToast('Prompt enhanced successfully!', 'success');
          } else {
            showToast('Failed to enhance the prompt.', 'error');
          }
        } catch (error) {
          console.error('Error enhancing prompt:', error);
          showToast('An error occurred while enhancing the prompt.', 'error');
        } finally {
          // Reset button state
          const enhanceButton = document.getElementById('enhance-prompt-button');
          enhanceButton.textContent = 'Enhance Prompt';
          enhanceButton.disabled = false;
        }
      });*/

     

      // Function to update the token count in the navbar
      function updateTokenCount(amount) {
        const tokenCountElement = document.getElementById('token-count');
        if (tokenCountElement) {
          let currentTokens = parseInt(tokenCountElement.textContent.replace('Tokens: ', '')) || 0;
          currentTokens += amount;
          tokenCountElement.textContent = `Tokens: ${currentTokens}`;

          // Optionally, update backend if needed
          // Example: send updated token count to backend
        }
      }

      // Handle Public/Profile Toggle Buttons
      document.getElementById('public-toggle').addEventListener('click', () => {
          // Hide or clear the user profile elements
          const profileUsername = document.getElementById('profile-username');
          const profileAvatar = document.getElementById('profile-avatar');
          profileUsername.textContent = ''; // Clear username
          profileAvatar.src = ''; // Clear avatar
          profileAvatar.classList.add('hidden'); // Hide avatar

          // Reset pagination state when switching to Public Posts
          page = 1; // Reset the page number
          hasMoreImages = true; // Ensure hasMoreImages is set to true

          // Toggle button styles
          document.getElementById('public-toggle').classList.add('selected-toggle');
          document.getElementById('profile-toggle').classList.remove('selected-toggle');

          // Clear existing images from the list if needed
          const imageList = document.getElementById('image-list');
          if (imageList) {
            imageList.innerHTML = ''; // Clear current images to load new ones
          }

          // Load public posts
          loadPublicPosts();
          history.pushState(null, '', '/');
        });



       document.getElementById('profile-toggle').addEventListener('click', async () => {
          // Hide or clear the user profile elements
          const profileUsername = document.getElementById('profile-username');
          const profileAvatar = document.getElementById('profile-avatar');
          profileUsername.textContent = ''; // Clear username
          profileAvatar.src = ''; // Clear avatar
          profileAvatar.classList.add('hidden'); // Hide avatar

          // Fetch user data to check authentication
          let userData;
          try {
            const response = await fetch('/user-data');
            userData = await response.json();
          } catch (error) {
            console.error('Error fetching user data:', error);
            showToast('An error occurred. Please try again.', 'error');
            return;
          }

          if (!userData.loggedIn) {
            // Display a message prompting the user to log in
            showToast('Please log in to view your posts.', 'error');
            return;
          }

          // Toggle button styles
          document.getElementById('profile-toggle').classList.add('selected-toggle');
          document.getElementById('public-toggle').classList.remove('selected-toggle');

          // Load private/profile posts
          loadPrivatePosts();
        });


      // Handle Buy Tokens Selection
      document.querySelectorAll('.select-token-button').forEach(button => {
        button.addEventListener('click', async () => {
          const tokens = parseInt(button.getAttribute('data-tokens'));
          const price = parseFloat(button.getAttribute('data-price'));

          try {
            if (tokens === 0) {
              showToast('The Free package offers 0 tokens.', 'error');
              return;
            }

            // Initiate payment process via backend
            const response = await fetch('/buy-tokens', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tokens, price }),
            });

            const data = await response.json();

            if (response.ok) {
              showToast(`Successfully purchased ${tokens} tokens!`, 'success');
              // Update token count in navbar
              updateTokenCount(tokens);
              // Close the Buy Tokens Modal
              closeModal('buy-tokens-modal');
            } else {
              showToast(data.error || 'Failed to purchase tokens.', 'error');
            }
          } catch (error) {
            console.error('Error purchasing tokens:', error);
            showToast('An error occurred while purchasing tokens.', 'error');
          }
        });
      });

     
 



      // Accessibility: Close any open modals when focusing on the prompt input
      const promptInput = document.getElementById('prompt-input');
      if (promptInput) {
        promptInput.addEventListener('focus', () => {
          for (let modalId in modals) {
            if (!modals[modalId].classList.contains('hidden')) {
              closeModal(modalId);
            }
          }
        });
      }
    }

    // Function to populate the character dropdown
    function populateCharacterDropdown() {
      const characterSelect = document.getElementById('character-select');
      if (!characterSelect) return;

      characterSelect.innerHTML = '<option value="" disabled selected>Select Character</option>'; // Reset options

      const characters = JSON.parse(localStorage.getItem('characters')) || [];
      characters.forEach((char, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = char.name;
        characterSelect.appendChild(option);
      });
    }

  
   function showFullSizeImage(imageUrl) {
      // Create a modal element
      const modal = document.createElement('div');
      modal.classList.add('fixed', 'inset-0', 'bg-black', 'bg-opacity-75', 'flex', 'justify-center', 'items-center', 'z-50');
      modal.innerHTML = `
        <div class="relative">
          <img src="${imageUrl}" alt="Full Image" class="max-w-full max-h-screen rounded-lg">
          <button class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full" id="close-modal">&times;</button>
        </div>
      `;

      // Append modal to the document body
      document.body.appendChild(modal);

      // Add event listener to close the modal when clicking the close button or outside the image
      modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target.id === 'close-modal') {
          modal.remove();
        }
      });
       
} //End events 

      


async function loadComments(imageId) {
  try {
    const response = await fetch(`/images/${imageId}/comments`);
    if (!response.ok) {
      throw new Error('Failed to fetch comments.');
    }

    const comments = await response.json();

    const commentsList = document.getElementById('comments-list');
    commentsList.innerHTML = ''; // Clear old comments

    comments.forEach(comment => {
      const li = document.createElement('li');
      li.classList.add('flex', 'items-start', 'space-x-2'); // For layout
      li.innerHTML = `
        <img src="${comment.avatar}" alt="${comment.username}" class="w-8 h-8 rounded-full" crossorigin="anonymous" referrerPolicy="no-referrer" />
        <div>
          <p class="font-bold text-black">${comment.username}</p>
          <p class="text-gray-600">${comment.content}</p>
        </div>
      `;
      commentsList.appendChild(li);
    });
  } catch (error) {
    console.error('Error loading comments:', error);
  }
}



    
    // Function to load public posts with infinite scrolling support
    let page = 1; // Initial page number for pagination
    let isLoading = false; // Prevent multiple simultaneous requests
    let hasMoreImages = true; // Track if there are more images to load


    async function loadPublicPosts() {
      if (isLoading || !hasMoreImages) return;
      isLoading = true;

      try {
        const response = await fetch(`/api/public-posts?page=${page}&limit=10`);
        if (!response.ok) {
          throw new Error('Failed to load public posts');
        }
        const data = await response.json();
        const images = data.images;
        hasMoreImages = data.hasMore; // Update the hasMore flag based on server response

        const imageList = document.getElementById('image-list');
        if (!imageList) {
          console.error('Image List container not found in the DOM.');
          return;
        }

        images.forEach(image => {
          const imageCard = document.createElement('div');
          imageCard.classList.add('image-card', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

            
          imageCard.innerHTML = `<img src="${image.thumbnailUrl}" alt="Public Image" class="w-full h-auto rounded-lg" loading="lazy" />`;
            
          imageList.appendChild(imageCard);

          // Ensure the event listener is correctly attached to the image
          imageCard.querySelector('img').addEventListener('click', () => {              
              openCommentsModal(image.id, image.imageUrl, 'public'); // For public images
            });

        });

        page++; // Increment page number for the next load
      } catch (error) {
        console.error('Error loading public posts:', error);
        showToast('An error occurred while loading public posts.', 'error');
      } finally {
        isLoading = false;
      }
    }


    // Infinite scrolling logic
    window.addEventListener('scroll', () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && !isLoading && hasMoreImages) {
        loadPublicPosts();
      }
    });


   // Function to load private/profile posts
async function loadPrivatePosts() {
  try {
    const response = await fetch('/api/private-posts');
    if (!response.ok) {
      throw new Error('Failed to load profile posts');
    }
    const images = await response.json();
    const imageList = document.getElementById('image-list');
    if (!imageList) {
      console.error('Image List container not found in the DOM.');
      return;
    }
    imageList.innerHTML = ''; // Clear current images

    images.forEach(image => {
      const imageCard = document.createElement('div');
      imageCard.classList.add('image-card', 'rounded-lg', 'shadow-md', 'bg-gray-800', 'p-4', 'mb-4');

      // Badge indicating public or private
      const badge = image.isPublic 
        ? '<span class="badge-public">Public</span>'
        : '<span class="badge-private">Private</span>';

      // Choose the appropriate icon and tooltip for the toggle button
      const toggleIcon = image.isPublic ? '<i class="fas fa-lock"></i>' : '<i class="fas fa-globe"></i>';
      const toggleTooltip = image.isPublic ? 'Make Private' : 'Make Public';

      // Create a container for all action buttons
      const actionButtons = `
        <div class="action-buttons absolute top-2 right-2 flex space-x-2">
          <a href="${image.imageUrl}" download class="download-button bg-green-600 text-white p-1 rounded shadow hover:bg-green-500" title="Download">
            <i class="fas fa-download"></i>
          </a>
          <button class="delete-button bg-white text-red-600 p-1 rounded shadow hover:bg-gray-100" data-id="${image.id}" title="Delete">
            <i class="fas fa-trash"></i>
          </button>
          <button class="toggle-visibility-button bg-blue-600 text-white p-1 rounded shadow hover:bg-blue-500" data-id="${image.id}" title="${toggleTooltip}">
            ${toggleIcon}
          </button>
        </div>
      `;
      
      imageCard.innerHTML = `
        ${badge}
        <img src="${image.thumbnailUrl}" alt="${image.isPublic ? 'Public' : 'Private'} Image" class="w-full h-auto rounded-lg" loading="lazy" />
        ${actionButtons}
      `;

      imageList.appendChild(imageCard);

      // Add click event listener for full-size view
      imageCard.querySelector('img').addEventListener('click', () => {
          //showFullSizeImage(image.imageUrl);
          //showImagePopup(image);
          openCommentsModal(image.id, image.imageUrl, 'personal'); // For personal images
      });

      // Add click event listener for the delete button
      imageCard.querySelector('.delete-button').addEventListener('click', async (event) => {
        event.stopPropagation(); // Prevent triggering the full-size image view
        const imageId = event.target.closest('button').getAttribute('data-id');

        try {
          const response = await fetch(`/delete-private-image/${imageId}`, {
            method: 'DELETE',
          });

          if (response.ok) {
            showToast('Image deleted successfully!', 'success');
            imageCard.remove(); // Remove the card from the DOM
          } else {
            showToast('Failed to delete image', 'error');
          }
        } catch (error) {
          console.error('Error deleting image:', error);
          showToast('An error occurred while deleting the image', 'error');
        }
      });

      // Add click event listener for the toggle visibility button
      imageCard.querySelector('.toggle-visibility-button').addEventListener('click', async (event) => {
          event.stopPropagation(); // Prevent triggering the full-size image view
          const imageId = event.target.closest('button').getAttribute('data-id');

          try {
            const response = await fetch(`/update-image-visibility/${imageId}`, {
              method: 'PUT', 
              headers: { 'Content-Type': 'application/json' },
            });


            if (response.ok) {
              const data = await response.json();
              showToast('Image visibility updated!', 'success');
              // Optionally, refresh the view to reflect changes
              loadPrivatePosts();
            } else {
              showToast('Failed to update visibility', 'error');
            }
          } catch (error) {
            console.error('Error updating image visibility:', error);
            showToast('An error occurred while updating visibility', 'error');
          }
        });

        
        
    });
  } catch (error) {
    console.error('Error loading private posts:', error);
    showToast('An error occurred while loading your posts.', 'error');
  }
}




    // Function to show toast notifications
    function showToast(message, type = 'error') {
      const toastContainer = document.getElementById('toast-container');
      if (!toastContainer) {
        console.error('Toast container not found in the DOM.');
        return;
      }

      const toast = document.createElement('div');
      toast.classList.add('toast');

      if (type === 'success') {
        toast.classList.add('toast-success');
      } else {
        toast.classList.add('toast-error');
      }

      toast.textContent = message;
      toastContainer.appendChild(toast);

      // Remove the toast after 3 seconds with a fade-out animation
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.addEventListener('transitionend', () => {
          toast.remove();
        });
      }, 1000);
    }
      
      
    async function updateImageVisibility(imageId, isPublic) {
      try {
        const response = await fetch('/update-image-visibility', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ imageId, isPublic })
        });

        if (response.ok) {
          showToast(`Image visibility updated to ${isPublic ? 'public' : 'private'}!`, 'success');
        } else {
          showToast('Failed to update image visibility.', 'error');
        }
      } catch (error) {
        console.error('Error updating image visibility:', error);
        showToast('An error occurred while updating image visibility.', 'error');
      }
    }

      document.addEventListener('DOMContentLoaded', () => {
          const visibilityButton = document.getElementById('post-visibility-button');
          const visibilityIcon = document.getElementById('post-visibility-icon');
          const visibilityText = document.getElementById('post-visibility-text');
          const tooltip = document.getElementById('post-visibility-tooltip');

          visibilityButton.addEventListener('mouseover', () => {
            if (tooltip) {
              tooltip.classList.remove('hidden');
            }
          });

          visibilityButton.addEventListener('mouseout', () => {
            if (tooltip) {
              tooltip.classList.add('hidden');
            }
          });


          // Initial state: private (false)  
          updateVisibility();


          visibilityButton.addEventListener('click', () => {
            isPublic = !isPublic; // Toggle the state
            updateVisibility();
          });

          function updateVisibility() {
            if (isPublic) {
              // Public state
              visibilityIcon.innerHTML = `
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.522 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.478 0-8.268-2.943-9.542-7z" />
              `;
              visibilityText.textContent = 'Post Public';
              if (tooltip) tooltip.textContent = 'Create in public'; // Check if tooltip exists
            } else {
              // Private state
              visibilityIcon.innerHTML = `
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.542-7a10.048 10.048 0 012.13-3.962M9.879 9.879a3 3 0 104.243 4.243M15 12a3 3 0 01-6 0" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3l18 18" />
              `;
              visibilityText.textContent = 'Post Private';
              if (tooltip) tooltip.textContent = 'Create privately'; // Check if tooltip exists
            }
          }
    });

    document.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('status') === 'success') {
            showToast('Payment successful! Tokens have been added to your account.', 'success');
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
  const commentsModal = document.getElementById('comments-modal');
  const closeModalButton = document.getElementById('close-comments-modal');

  // Close the modal when the "x" button is clicked
  closeModalButton.addEventListener('click', () => {
    commentsModal.classList.add('hidden'); // Hide the modal
    history.pushState(null, '', window.location.origin);
  });

  // Close the modal when clicking outside the modal content
  commentsModal.addEventListener('click', (event) => {
    if (event.target === commentsModal) {
      commentsModal.classList.add('hidden'); // Hide the modal
      history.pushState(null, '', window.location.origin);    
    }
  });
        
  document.getElementById('post-comment').addEventListener('click', async () => {
      const commentInput = document.getElementById('comment-input');
      const commentText = commentInput.value.trim();
      const imageId = window.currentImageId;

      if (!commentText) {
        showToast('Please enter a comment.', 'error');
        return;
      }

      try {
                
        const response = await fetch(`/images/${imageId}/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: commentText }),
        });

        if (!response.ok) {
          throw new Error('Failed to post comment.');
        }

        const newComment = await response.json();

        const commentsList = document.getElementById('comments-list');
        const li = document.createElement('li');
        li.classList.add('flex', 'items-start', 'space-x-2');
        li.innerHTML = `
          <img src="${newComment.avatar}" alt="${newComment.username}" class="w-8 h-8 rounded-full" />
          <div>
            <p class="font-bold text-black">${newComment.username}</p>
            <p class="text-gray-600">${newComment.content}</p>
          </div>
        `;
        commentsList.appendChild(li);


        // Clear the comment input field
        commentInput.value = '';
        showToast('Comment posted successfully!', 'success');
      } catch (error) {
        console.error('Error posting comment:', error);
        showToast('Failed to post your comment. Please try again.', 'error');
      }
    });
        
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        commentsModal.classList.add('hidden'); // Hide the modal
      }
    });
        
    const modalImage = document.getElementById('modal-image');
  const fullscreenIcon = document.getElementById('fullscreen-icon');
  

  // Fullscreen Modal Function
  const showFullscreenModal = () => {
    const fullScreenModal = document.createElement('div');
    fullScreenModal.classList.add(
      'fixed',
      'inset-0',
      'bg-black',
      'bg-opacity-90',
      'flex',
      'justify-center',
      'items-center',
      'fullscreen-modal'
    );
    fullScreenModal.innerHTML = `
      <div class="relative">
        <img src="${modalImage.src}" alt="Full Image" class="max-w-full max-h-screen rounded-lg">
        <button class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full" id="close-fullscreen-modal">&times;</button>
      </div>
    `;
    document.body.appendChild(fullScreenModal);

    fullScreenModal.addEventListener('click', (e) => {
      if (e.target.id === 'close-fullscreen-modal' || e.target === fullScreenModal) {
        fullScreenModal.remove();
      }
    });
  };

  // Attach Fullscreen Modal Event Listeners
  modalImage.addEventListener('click', showFullscreenModal);
  fullscreenIcon.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent triggering image click
    showFullscreenModal();
  });

 
    // Handle profile link click
  document.getElementById('modal-user-profile').addEventListener('click', (e) => {
    e.preventDefault();
    const userId = e.currentTarget.getAttribute('data-user-id'); // Use e.currentTarget

    if (userId) {
      history.pushState(null, '', `/user-profile/${userId}`);
      loadUserProfile(userId);
    } else {
      console.error('User ID is null or undefined.');
      showToast('Unable to load user profile.', 'error');
    }
  });
    // Listen for navigation changes
    window.addEventListener('popstate', (event) => {
          const url = new URL(window.location.href);
          const path = url.pathname;

          if (path.startsWith('/user-profile/')) {
            const userId = path.split('/').pop(); // Extract user ID from the path
            loadUserProfile(userId);
          } else {
            // Handle other routes (e.g., load public posts)
            loadPublicPosts();
          }
    });
    
    
    const currentPath = window.location.pathname;
    const profileMatch = currentPath.match(/^\/user-profile\/(\d+)$/);

    if (profileMatch) {
        const userId = profileMatch[1];
        loadUserProfile(userId); // Fetch and display the profile
    }

    document.getElementById('logo').addEventListener('click', () => {
      // Hide or clear the user profile elements
      const profileUsername = document.getElementById('profile-username');
      const profileAvatar = document.getElementById('profile-avatar');
      profileUsername.textContent = ''; // Clear username
      profileAvatar.src = ''; // Clear avatar
      profileAvatar.classList.add('hidden'); // Hide avatar

      // Reset UI state for Public Posts
      const publicToggle = document.getElementById('public-toggle');
      const profileToggle = document.getElementById('profile-toggle');
      publicToggle.classList.add('selected-toggle'); // Highlight "Public Posts"
      profileToggle.classList.remove('selected-toggle'); // Unhighlight "Profile Posts"

      // Clear existing images from the list
      const imageList = document.getElementById('image-list');
      if (imageList) {
        imageList.innerHTML = ''; // Clear the image grid
      }

      // Reset pagination state for public posts
      page = 1; // Reset the page number
      hasMoreImages = true; // Ensure hasMoreImages is set to true

      // Load public posts
      loadPublicPosts();

      // Update the URL to the root path
      history.pushState(null, '', '/'); // Use '/' or the desired default path
    });

   const urlParams = new URLSearchParams(window.location.search);
  const imageId = urlParams.get('image');

  if (imageId) {
    // Fetch image details from the unified endpoint
    fetch(`/api/image-details/${imageId}`)
      .then(response => {
        if (!response.ok) {
          throw new Error('Image not found');
        }
        return response.json();
      })
      .then(data => {
        if (data) {
          // Open the comments modal with the fetched image details
          openCommentsModal(imageId, data.imageUrl, data.isPublic ? 'public' : 'personal');
        } else {
          console.error('Image details could not be found.');
        }
      })
      .catch(error => {
        console.error('Error fetching image details:', error);
        showToast('The requested image could not be found or is no longer available.', 'error');
      });
  }
        
});


document.addEventListener('DOMContentLoaded', async () => {
      
  const commentInput = document.getElementById('comment-input');
  const postCommentButton = document.getElementById('post-comment');

  try {
    const response = await fetch('/user-data'); // Fetch user data
    const userData = await response.json();

    if (!userData.loggedIn) {
      commentInput.disabled = true; // Disable the input box
      commentInput.placeholder = 'Please log in to comment';
      postCommentButton.disabled = true;
    }
  } catch (error) {
    console.error('Error checking login status:', error);
  }
    
      
});

document.addEventListener("DOMContentLoaded", async () => {
  const response = await fetch("/check-auth", { method: "GET" });
  const data = await response.json();

  const promptInput = document.getElementById("prompt-input");
  const generateButton = document.getElementById("generate-button");

  if (!data.isAuthenticated) {
    // Disable prompt box and button
    promptInput.disabled = true;
    generateButton.disabled = true;

    // Add placeholder text to indicate the user must log in
    promptInput.placeholder = "Please log in to create images.";
  }
});



  </script>
</body>
</html>
